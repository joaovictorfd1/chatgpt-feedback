"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.22.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n        // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n        // web extensions. Relevant Bugzilla tickets:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : 0;\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        }\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? name + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"unstable_viewTransition\",\n    \"children\"\n], _excluded3 = [\n    \"fetcherKey\",\n    \"navigate\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"relative\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n];\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\n//\n// It is replaced with the proper version at build time via a babel plugin in\n// the rollup config.\n//\n// Export a global property onto the window for React Router detection by the\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n// to detect and properly classify live websites as being built with React Router:\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\nconst REACT_ROUTER_VERSION = \"6\";\ntry {\n    window.__reactRouterVersion = REACT_ROUTER_VERSION;\n} catch (e) {\n// no-op\n}\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        // @ts-expect-error\n                        let error = new ErrorConstructor(val.message);\n                        // Wipe away the client-side stack trace.  Nothing to fill it in with\n                        // because we don't serialize SSR stack traces for security reasons\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {\n                    // no-op - fall through and create a normal Error\n                    }\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    isTransitioning: false\n});\nif (true) {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (true) {\n    FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = react_dom__WEBPACK_IMPORTED_MODULE_1__[FLUSH_SYNC];\nconst USE_ID = \"useId\";\nconst useIdImpl = react__WEBPACK_IMPORTED_MODULE_0__[USE_ID];\nfunction startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n        startTransitionImpl(cb);\n    } else {\n        cb();\n    }\n}\nfunction flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n        flushSyncImpl(cb);\n    } else {\n        cb();\n    }\n}\nclass Deferred {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n    let { v7_startTransition } = future || {};\n    let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cb)=>{\n        if (v7_startTransition) {\n            startTransitionSafe(cb);\n        } else {\n            cb();\n        }\n    }, [\n        v7_startTransition\n    ]);\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2)=>{\n        let { deletedFetchers, unstable_flushSync: flushSync, unstable_viewTransitionOpts: viewTransitionOpts } = _ref2;\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== undefined) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n        // If this isn't a view transition or it's not available in this browser,\n        // just update and be done with it\n        if (!viewTransitionOpts || isViewTransitionUnavailable) {\n            if (flushSync) {\n                flushSyncSafe(()=>setStateImpl(newState));\n            } else {\n                optInStartTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        // flushSync + startViewTransition\n        if (flushSync) {\n            // Flush through the context to mark DOM elements as transition=ing\n            flushSyncSafe(()=>{\n                // Cancel any pending transitions\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            // Update the DOM\n            let t = router.window.document.startViewTransition(()=>{\n                flushSyncSafe(()=>setStateImpl(newState));\n            });\n            // Clean up after the animation completes\n            t.finished.finally(()=>{\n                flushSyncSafe(()=>{\n                    setRenderDfd(undefined);\n                    setTransition(undefined);\n                    setPendingState(undefined);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            flushSyncSafe(()=>setTransition(t));\n            return;\n        }\n        // startTransition + startViewTransition\n        if (transition) {\n            // Interrupting an in-progress transition, cancel and let everything flush\n            // out, and then kick off a new transition from the interruption state\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            // Completed navigation update with opted-in view transitions, let 'er rip\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        transition,\n        renderDfd,\n        fetcherData,\n        optInStartTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition = router.window.document.startViewTransition(async ()=>{\n                optInStartTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition.finished.finally(()=>{\n                setRenderDfd(undefined);\n                setTransition(undefined);\n                setPendingState(undefined);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition);\n        }\n    }, [\n        optInStartTransition,\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(undefined);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n    let { routes, future, state } = _ref3;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRoutesImpl)(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref4) {\n    let { basename, children, future, window: window1 } = _ref4;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref5) {\n    let { basename, children, future, window: window1 } = _ref5;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref6) {\n    let { basename, children, future, history } = _ref6;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset, unstable_viewTransition } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    }\n    // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, unstable_viewTransition, children } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    let { navigator, basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n        nextLocationPathname = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to,\n        unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef)=>{\n    let { fetcherKey, navigate, reloadDocument, replace, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, unstable_viewTransition } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace,\n            state,\n            relative,\n            preventScrollReset,\n            unstable_viewTransition\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref10) {\n    let { getKey, storageKey } = _ref10;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative, unstable_viewTransition } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative,\n                unstable_viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nfunction validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n        throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = ()=>\"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        validateClientSideSubmission();\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                unstable_flushSync: options.unstable_flushSync\n            });\n        } else {\n            router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                unstable_flushSync: options.unstable_flushSync,\n                unstable_viewTransition: options.unstable_viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(action ? action : \".\", {\n        relative\n    }));\n    // If no action was specified, browsers will persist current search params\n    // when determining the path, so match that behavior\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    if (action == null) {\n        // Safe to write to this directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        path.search = location.search;\n        // When grabbing search params from the URL, remove any included ?index param\n        // since it might not apply to our contextual route.  We add it back based\n        // on match.route.index below\n        let params = new URLSearchParams(path.search);\n        if (params.has(\"index\") && params.get(\"index\") === \"\") {\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher(_temp3) {\n    var _route$matches;\n    let { key } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    // Fetcher key handling\n    // OK to call conditionally to feature detect `useId`\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    let defaultKey = useIdImpl ? useIdImpl() : \"\";\n    let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    } else if (!fetcherKey) {\n        // We will only fall through here when `useId` is not available\n        setFetcherKey(getUniqueFetcherId());\n    }\n    // Registration/cleanup\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>{\n            // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n            // will not delete immediately but instead queue up a delete after the\n            // fetcher returns to an `idle` state\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    // Fetcher additions\n    let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts)=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n        router.fetch(fetcherKey, routeId, href, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts)=>{\n        submitImpl(target, _extends({}, opts, {\n            navigate: false,\n            fetcherKey\n        }));\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n                navigate: false,\n                fetcherKey: fetcherKey,\n                ref: ref\n            }));\n        });\n        if (true) {\n            FetcherForm.displayName = \"fetcher.Form\";\n        }\n        return FetcherForm;\n    }, [\n        fetcherKey\n    ]);\n    // Exposed FetcherWithComponents\n    let fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__.IDLE_FETCHER;\n    let data = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form: FetcherForm,\n            submit,\n            load\n        }, fetcher, {\n            data\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map((_ref11)=>{\n        let [key, fetcher] = _ref11;\n        return _extends({}, fetcher, {\n            key\n        });\n    });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp4) {\n    let { getKey, storageKey } = _temp4 === void 0 ? {} : _temp4;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n             true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {\n            // no-op, use default empty object\n            }\n        }, [\n            storageKey\n        ]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches)=>getKey(_extends({}, location, {\n                    pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(location.pathname, basename) || location.pathname\n                }), matches) : getKey;\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKeyWithoutBasename);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            }\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref12) {\n    let { when, message } = _ref12;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                // This timeout is needed to avoid a weird \"race\" on POP navigations\n                // between the `window.history` revert navigation and the result of\n                // `window.confirm`\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */ function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n    !(vtContext != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\n    let { basename } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, currentPath) != null;\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ087QUFDbVI7QUFDMGU7QUFDMWxCO0FBRXpNLFNBQVNnRTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBQ0EsU0FBU1EsOEJBQThCTixNQUFNLEVBQUVPLFFBQVE7SUFDckQsSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7SUFDZCxJQUFJWSxhQUFhZixPQUFPZ0IsSUFBSSxDQUFDVDtJQUM3QixJQUFJQyxLQUFLSjtJQUNULElBQUtBLElBQUksR0FBR0EsSUFBSVcsV0FBV1QsTUFBTSxFQUFFRixJQUFLO1FBQ3RDSSxNQUFNTyxVQUFVLENBQUNYLEVBQUU7UUFDbkIsSUFBSVUsU0FBU0csT0FBTyxDQUFDVCxRQUFRLEdBQUc7UUFDaENMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUND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S0FBSztJQUNoUyxJQUFJLEVBQ0ZzRSxRQUFRLEVBQ1QsR0FBR3lPLHFCQUFxQkosZUFBZXJDLHNCQUFzQjtJQUM5RCxJQUFJcEIsT0FBT3RTLDZEQUFlQSxDQUFDeVAsSUFBSTtRQUM3QitCLFVBQVV6SSxLQUFLeUksUUFBUTtJQUN6QjtJQUNBLElBQUksQ0FBQy9FLFVBQVU3QixlQUFlLEVBQUU7UUFDOUIsT0FBTztJQUNUO0lBQ0EsSUFBSThRLGNBQWM1WSwyREFBYUEsQ0FBQzJKLFVBQVU2QixlQUFlLENBQUNpRSxRQUFRLEVBQUU3SyxhQUFhK0UsVUFBVTZCLGVBQWUsQ0FBQ2lFLFFBQVE7SUFDbkgsSUFBSW9KLFdBQVc3WSwyREFBYUEsQ0FBQzJKLFVBQVU4QixZQUFZLENBQUNnRSxRQUFRLEVBQUU3SyxhQUFhK0UsVUFBVThCLFlBQVksQ0FBQ2dFLFFBQVE7SUFDMUcsc0VBQXNFO0lBQ3RFLHNFQUFzRTtJQUN0RSxtRUFBbUU7SUFDbkUsRUFBRTtJQUNGLHNEQUFzRDtJQUN0RCxFQUFFO0lBQ0YscURBQXFEO0lBQ3JELEVBQUU7SUFDRixpREFBaUQ7SUFDakQsRUFBRTtJQUNGLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsa0RBQWtEO0lBQ2xELE9BQU85USx1REFBU0EsQ0FBQzZRLEtBQUtDLFFBQVEsRUFBRW9KLGFBQWEsUUFBUWxhLHVEQUFTQSxDQUFDNlEsS0FBS0MsUUFBUSxFQUFFbUosZ0JBQWdCO0FBQ2hHO0FBQ0EsWUFBWTtBQUVraEIsQ0FDOWhCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRncHQtZmVlZGJhY2svLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzPzAzYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgRE9NIHY2LjIyLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIFJvdXRlciwgVU5TQUZFX3VzZVJvdXRlc0ltcGwsIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgdXNlSHJlZiwgdXNlUmVzb2x2ZWRQYXRoLCB1c2VMb2NhdGlvbiwgdXNlTmF2aWdhdGUsIGNyZWF0ZVBhdGgsIFVOU0FGRV91c2VSb3V0ZUlkLCBVTlNBRkVfUm91dGVDb250ZXh0LCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0aW9uLCB1c2VCbG9ja2VyIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgTmF2aWdhdGlvblR5cGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIFVOU0FGRV91c2VSb3V0ZUlkLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVkaXJlY3REb2N1bWVudCwgcmVuZGVyTWF0Y2hlcywgcmVzb2x2ZVBhdGgsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUJsb2NrZXIsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgeyBzdHJpcEJhc2VuYW1lLCBVTlNBRkVfd2FybmluZywgY3JlYXRlUm91dGVyLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCwgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBJRExFX0ZFVENIRVIsIG1hdGNoUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBkZWZhdWx0TWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgKFxuICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiZcbiAgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgIHJldHVybiBtZW1vLmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dKTtcbiAgfSwgW10pKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVzZSBgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKC4uLilgIGhlcmUgaW5zdGVhZCBvZiBpdGVyYXRpbmcgb2ZcbiAgICAvLyBgZGVmYXVsdFNlYXJjaFBhcmFtcy5rZXlzKClgIHRvIHdvcmstYXJvdW5kIGEgYnVnIGluIEZpcmVmb3ggcmVsYXRlZCB0b1xuICAgIC8vIHdlYiBleHRlbnNpb25zLiBSZWxldmFudCBCdWd6aWxsYSB0aWNrZXRzOlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTQ2MDJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDIzOTg0XG4gICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbi8vIE9uZS10aW1lIGNoZWNrIGZvciBzdWJtaXR0ZXIgc3VwcG9ydFxubGV0IF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gbnVsbDtcbmZ1bmN0aW9uIGlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSB7XG4gIGlmIChfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRm9ybURhdGEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlmIEZvcm1EYXRhIHN1cHBvcnRzIHRoZSBzdWJtaXR0ZXIgcGFyYW1ldGVyLCB0aGlzIHdpbGwgdGhyb3dcbiAgICAgIDApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbmNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IG5ldyBTZXQoW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0pO1xuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZSkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiXFxcIlwiICsgZW5jVHlwZSArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBgZW5jVHlwZWAgZm9yIGA8Rm9ybT5gL2A8ZmV0Y2hlci5Gb3JtPmAgXCIgKyAoXCJhbmQgd2lsbCBkZWZhdWx0IHRvIFxcXCJcIiArIGRlZmF1bHRFbmNUeXBlICsgXCJcXFwiXCIpKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gIGxldCBtZXRob2Q7XG4gIGxldCBhY3Rpb247XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG4gIGxldCBib2R5O1xuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIj4gd2l0aG91dCBhIDxmb3JtPlwiKTtcbiAgICB9XG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8IGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgLy8gQnVpbGQgYSBGb3JtRGF0YSBvYmplY3QgcG9wdWxhdGVkIGZyb20gYSBmb3JtIGFuZCBzdWJtaXR0ZXJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcbiAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gbmFtZSArIFwiLlwiIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieFwiLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInlcIiwgXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBcIiArIFwiPGlucHV0IHR5cGU9XFxcInN1Ym1pdHxpbWFnZVxcXCI+XCIpO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID0gbnVsbDtcbiAgICBlbmNUeXBlID0gZGVmYXVsdEVuY1R5cGU7XG4gICAgYm9keSA9IHRhcmdldDtcbiAgfVxuICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxuICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb24sXG4gICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICBlbmNUeXBlLFxuICAgIGZvcm1EYXRhLFxuICAgIGJvZHlcbiAgfTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wib25DbGlja1wiLCBcInJlbGF0aXZlXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJ0YXJnZXRcIiwgXCJ0b1wiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiYXJpYS1jdXJyZW50XCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcImNsYXNzTmFtZVwiLCBcImVuZFwiLCBcInN0eWxlXCIsIFwidG9cIiwgXCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvblwiLCBcImNoaWxkcmVuXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiZmV0Y2hlcktleVwiLCBcIm5hdmlnYXRlXCIsIFwicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJtZXRob2RcIiwgXCJhY3Rpb25cIiwgXCJvblN1Ym1pdFwiLCBcInJlbGF0aXZlXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIl07XG4vLyBIRVkgWU9VISBET04nVCBUT1VDSCBUSElTIFZBUklBQkxFIVxuLy9cbi8vIEl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIHByb3BlciB2ZXJzaW9uIGF0IGJ1aWxkIHRpbWUgdmlhIGEgYmFiZWwgcGx1Z2luIGluXG4vLyB0aGUgcm9sbHVwIGNvbmZpZy5cbi8vXG4vLyBFeHBvcnQgYSBnbG9iYWwgcHJvcGVydHkgb250byB0aGUgd2luZG93IGZvciBSZWFjdCBSb3V0ZXIgZGV0ZWN0aW9uIGJ5IHRoZVxuLy8gQ29yZSBXZWIgVml0YWxzIFRlY2hub2xvZ3kgUmVwb3J0LiAgVGhpcyB3YXkgdGhleSBjYW4gY29uZmlndXJlIHRoZSBgd2FwcGFseXplcmBcbi8vIHRvIGRldGVjdCBhbmQgcHJvcGVybHkgY2xhc3NpZnkgbGl2ZSB3ZWJzaXRlcyBhcyBiZWluZyBidWlsdCB3aXRoIFJlYWN0IFJvdXRlcjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IVFRQQXJjaGl2ZS93YXBwYWx5emVyL2Jsb2IvbWFpbi9zcmMvdGVjaG5vbG9naWVzL3IuanNvblxuY29uc3QgUkVBQ1RfUk9VVEVSX1ZFUlNJT04gPSBcIjZcIjtcbnRyeSB7XG4gIHdpbmRvdy5fX3JlYWN0Um91dGVyVmVyc2lvbiA9IFJFQUNUX1JPVVRFUl9WRVJTSU9OO1xufSBjYXRjaCAoZSkge1xuICAvLyBuby1vcFxufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCkge1xuICB2YXIgX3dpbmRvdztcbiAgbGV0IHN0YXRlID0gKF93aW5kb3cgPSB3aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmVycm9ycykge1xuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICBlcnJvcnM6IGRlc2VyaWFsaXplRXJyb3JzKHN0YXRlLmVycm9ycylcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIC8vIEhleSB5b3UhICBJZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSBjaGFuZ2UgdGhlIGNvcnJlc3BvbmRpbmcgbG9naWMgaW5cbiAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXG4gICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBuZXcgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsKHZhbC5zdGF0dXMsIHZhbC5zdGF0dXNUZXh0LCB2YWwuZGF0YSwgdmFsLmludGVybmFsID09PSB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gcmVjb25zdHJ1Y3QgdGhlIHJpZ2h0IHR5cGUgb2YgRXJyb3IgKGkuZS4sIFJlZmVyZW5jZUVycm9yKVxuICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3JDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm8tb3AgLSBmYWxsIHRocm91Z2ggYW5kIGNyZWF0ZSBhIG5vcm1hbCBFcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmlhbGl6ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XG4gICAgICAgIC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5jb25zdCBWaWV3VHJhbnNpdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGlzVHJhbnNpdGlvbmluZzogZmFsc2Vcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBWaWV3VHJhbnNpdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlZpZXdUcmFuc2l0aW9uXCI7XG59XG5jb25zdCBGZXRjaGVyc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChuZXcgTWFwKCkpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBGZXRjaGVyc0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZldGNoZXJzXCI7XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gQ29tcG9uZW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuY29uc3QgRkxVU0hfU1lOQyA9IFwiZmx1c2hTeW5jXCI7XG5jb25zdCBmbHVzaFN5bmNJbXBsID0gUmVhY3RET01bRkxVU0hfU1lOQ107XG5jb25zdCBVU0VfSUQgPSBcInVzZUlkXCI7XG5jb25zdCB1c2VJZEltcGwgPSBSZWFjdFtVU0VfSURdO1xuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uU2FmZShjYikge1xuICBpZiAoc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xuICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1NhZmUoY2IpIHtcbiAgaWYgKGZsdXNoU3luY0ltcGwpIHtcbiAgICBmbHVzaFN5bmNJbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5jbGFzcyBEZWZlcnJlZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gdmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxuICovXG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZmFsbGJhY2tFbGVtZW50LFxuICAgIHJvdXRlcixcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbdnRDb250ZXh0LCBzZXRWdENvbnRleHRdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIGxldCBbcmVuZGVyRGZkLCBzZXRSZW5kZXJEZmRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QudXNlUmVmKG5ldyBNYXAoKSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBvcHRJblN0YXJ0VHJhbnNpdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGNiID0+IHtcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25TYWZlKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0sIFt2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld1N0YXRlLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBkZWxldGVkRmV0Y2hlcnMsXG4gICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogdmlld1RyYW5zaXRpb25PcHRzXG4gICAgfSA9IF9yZWYyO1xuICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKGtleSA9PiBmZXRjaGVyRGF0YS5jdXJyZW50LmRlbGV0ZShrZXkpKTtcbiAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSA9IHJvdXRlci53aW5kb3cgPT0gbnVsbCB8fCB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uICE9PSBcImZ1bmN0aW9uXCI7XG4gICAgLy8gSWYgdGhpcyBpc24ndCBhIHZpZXcgdHJhbnNpdGlvbiBvciBpdCdzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLFxuICAgIC8vIGp1c3QgdXBkYXRlIGFuZCBiZSBkb25lIHdpdGggaXRcbiAgICBpZiAoIXZpZXdUcmFuc2l0aW9uT3B0cyB8fCBpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUpIHtcbiAgICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmbHVzaFN5bmMgKyBzdGFydFZpZXdUcmFuc2l0aW9uXG4gICAgaWYgKGZsdXNoU3luYykge1xuICAgICAgLy8gRmx1c2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBtYXJrIERPTSBlbGVtZW50cyBhcyB0cmFuc2l0aW9uPWluZ1xuICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2l0aW9uc1xuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gVXBkYXRlIHRoZSBET01cbiAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgIHQuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFRyYW5zaXRpb24odW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRQZW5kaW5nU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRUcmFuc2l0aW9uKHQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc3RhcnRUcmFuc2l0aW9uICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAvLyBJbnRlcnJ1cHRpbmcgYW4gaW4tcHJvZ3Jlc3MgdHJhbnNpdGlvbiwgY2FuY2VsIGFuZCBsZXQgZXZlcnl0aGluZyBmbHVzaFxuICAgICAgLy8gb3V0LCBhbmQgdGhlbiBraWNrIG9mZiBhIG5ldyB0cmFuc2l0aW9uIGZyb20gdGhlIGludGVycnVwdGlvbiBzdGF0ZVxuICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcGxldGVkIG5hdmlnYXRpb24gdXBkYXRlIHdpdGggb3B0ZWQtaW4gdmlldyB0cmFuc2l0aW9ucywgbGV0ICdlciByaXBcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIud2luZG93LCB0cmFuc2l0aW9uLCByZW5kZXJEZmQsIGZldGNoZXJEYXRhLCBvcHRJblN0YXJ0VHJhbnNpdGlvbl0pO1xuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIC8vIFdoZW4gd2Ugc3RhcnQgYSB2aWV3IHRyYW5zaXRpb24sIGNyZWF0ZSBhIERlZmVycmVkIHdlIGNhbiB1c2UgZm9yIHRoZVxuICAvLyBldmVudHVhbCBcImNvbXBsZXRlZFwiIHJlbmRlclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XG4gICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkKCkpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dF0pO1xuICAvLyBPbmNlIHRoZSBkZWZlcnJlZCBpcyBjcmVhdGVkLCBraWNrIG9mZiBzdGFydFZpZXdUcmFuc2l0aW9uKCkgdG8gdXBkYXRlIHRoZVxuICAvLyBET00gYW5kIHRoZW4gd2FpdCBvbiB0aGUgRGVmZXJyZWQgdG8gcmVzb2x2ZSAoaW5kaWNhdGluZyB0aGUgRE9NIHVwZGF0ZSBoYXNcbiAgLy8gaGFwcGVuZWQpXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xuICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgIGxldCB0cmFuc2l0aW9uID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfVxuICB9LCBbb3B0SW5TdGFydFRyYW5zaXRpb24sIHBlbmRpbmdTdGF0ZSwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG4gIC8vIFdoZW4gdGhlIG5ldyBsb2NhdGlvbiBmaW5hbGx5IHJlbmRlcnMgYW5kIGlzIGNvbW1pdHRlZCB0byB0aGUgRE9NLCB0aGlzXG4gIC8vIGVmZmVjdCB3aWxsIHJ1biB0byByZXNvbHZlIHRoZSB0cmFuc2l0aW9uXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgc3RhdGUubG9jYXRpb24ua2V5ID09PSBwZW5kaW5nU3RhdGUubG9jYXRpb24ua2V5KSB7XG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwgW3JlbmRlckRmZCwgdHJhbnNpdGlvbiwgc3RhdGUubG9jYXRpb24sIHBlbmRpbmdTdGF0ZV0pO1xuICAvLyBJZiB3ZSBnZXQgaW50ZXJydXB0ZWQgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uIGR1cmluZyBhIHRyYW5zaXRpb24sIHdlIHNraXBcbiAgLy8gdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBsZXQgaXQgY2xlYW51cCwgdGhlbiBraWNrIGl0IG9mZiBhZ2FpbiBoZXJlXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbGxiYWNrRWxlbWVudCA9PSBudWxsIHx8ICFyb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgOiB2b2lkIDA7XG4gICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IGZhbHNlLFxuICAgIGJhc2VuYW1lXG4gIH0pLCBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXSk7XG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0YXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBmZXRjaGVyRGF0YS5jdXJyZW50XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2dENvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBmdXR1cmU6IHtcbiAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiByb3V0ZXIuZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoXG4gICAgfVxuICB9LCBzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVzLCB7XG4gICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSkpKSwgbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgcm91dGVzLFxuICAgIGZ1dHVyZSxcbiAgICBzdGF0ZVxuICB9ID0gX3JlZjM7XG4gIHJldHVybiBVTlNBRkVfdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUsIGZ1dHVyZSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBmdXR1cmUsXG4gICAgd2luZG93XG4gIH0gPSBfcmVmNDtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgZnV0dXJlOiBmdXR1cmVcbiAgfSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBmdXR1cmUsXG4gICAgd2luZG93XG4gIH0gPSBfcmVmNTtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3Rvcnkoe1xuICAgICAgd2luZG93LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgZnV0dXJlOiBmdXR1cmVcbiAgfSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIGhpc3RvcnlcbiAgfSA9IF9yZWY2O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeSxcbiAgICBmdXR1cmU6IGZ1dHVyZVxuICB9KTtcbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgYDxhPmAuXG4gKi9cbmNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rV2l0aFJlZihfcmVmNywgcmVmKSB7XG4gIGxldCB7XG4gICAgICBvbkNsaWNrLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9ID0gX3JlZjcsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY3LCBfZXhjbHVkZWQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcbiAgbGV0IGFic29sdXRlSHJlZjtcbiAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAvLyBSZW5kZXIgdGhlIGFic29sdXRlIGhyZWYgc2VydmVyLSBhbmQgY2xpZW50LXNpZGVcbiAgICBhYnNvbHV0ZUhyZWYgPSB0bztcbiAgICAvLyBPbmx5IGNoZWNrIGZvciBleHRlcm5hbCBvcmlnaW5zIGNsaWVudC1zaWRlXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgbGV0IHRhcmdldFVybCA9IHRvLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKSA6IG5ldyBVUkwodG8pO1xuICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luL2Jhc2VuYW1lIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgICAgdG8gPSBwYXRoICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IGRvIGV4dGVybmFsIFVSTCBkZXRlY3Rpb24gd2l0aG91dCBhIHZhbGlkIFVSTFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCI8TGluayB0bz1cXFwiXCIgKyB0byArIFwiXFxcIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayBcIiArIFwid2hlbiBjbGlja2VkIC0gcGxlYXNlIHVwZGF0ZSB0byBhIHZhbGlkIFVSTCBwYXRoLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgcmVsYXRpdmUgVVJMc1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSk7XG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZixcbiAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICByZWY6IHJlZixcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSkpXG4gICk7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuLyoqXG4gKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5jb25zdCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoX3JlZjgsIHJlZikge1xuICBsZXQge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY4LFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOCwgX2V4Y2x1ZGVkMik7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmVcbiAgfSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIG5hdmlnYXRvcixcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJlxuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHBhdGgpICYmIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uID09PSB0cnVlO1xuICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWUgOiBudWxsO1xuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgPyBuZXh0TG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGlmIChuZXh0TG9jYXRpb25QYXRobmFtZSAmJiBiYXNlbmFtZSkge1xuICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb25QYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvblBhdGhuYW1lO1xuICB9XG4gIC8vIElmIHRoZSBgdG9gIGhhcyBhIHRyYWlsaW5nIHNsYXNoLCBsb29rIGF0IHRoYXQgZXhhY3Qgc3BvdC4gIE90aGVyd2lzZSxcbiAgLy8gd2UncmUgbG9va2luZyBmb3IgYSBzbGFzaCBfYWZ0ZXJfIHdoYXQncyBpbiBgdG9gLiAgRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIDxOYXZMaW5rIHRvPVwiL3VzZXJzXCI+IGFuZCA8TmF2TGluayB0bz1cIi91c2Vycy9cIj5cbiAgLy8gYm90aCB3YW50IHRvIGxvb2sgZm9yIGEgLyBhdCBpbmRleCA2IHRvIG1hdGNoIFVSTCBgL3VzZXJzL21hdHRgXG4gIGNvbnN0IGVuZFNsYXNoUG9zaXRpb24gPSB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUubGVuZ3RoIC0gMSA6IHRvUGF0aG5hbWUubGVuZ3RoO1xuICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIjtcbiAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICBpc0FjdGl2ZSxcbiAgICBpc1BlbmRpbmcsXG4gICAgaXNUcmFuc2l0aW9uaW5nXG4gIH07XG4gIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuICBsZXQgY2xhc3NOYW1lO1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCwgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLCBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdG86IHRvLFxuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uOiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlbik7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuLyoqXG4gKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICovXG5jb25zdCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF9yZWY5LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHtcbiAgICAgIGZldGNoZXJLZXksXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICAgIGFjdGlvbixcbiAgICAgIG9uU3VibWl0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0gPSBfcmVmOSxcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY5LCBfZXhjbHVkZWQzKTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gIGxldCBzdWJtaXRIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICBsZXQgc3VibWl0TWV0aG9kID0gKHN1Ym1pdHRlciA9PSBudWxsID8gdm9pZCAwIDogc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikpIHx8IG1ldGhvZDtcbiAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgIGZldGNoZXJLZXksXG4gICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlclxuICB9LCBwcm9wcykpO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbihfcmVmMTApIHtcbiAgbGV0IHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9ID0gX3JlZjEwO1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTY3JvbGxSZXN0b3JhdGlvbi5kaXNwbGF5TmFtZSA9IFwiU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn1cbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIb29rc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBEYXRhUm91dGVySG9vaztcbihmdW5jdGlvbiAoRGF0YVJvdXRlckhvb2spIHtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRcIl0gPSBcInVzZVN1Ym1pdFwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdEZldGNoZXJcIl0gPSBcInVzZVN1Ym1pdEZldGNoZXJcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1widXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiXSA9IFwidXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiO1xufSkoRGF0YVJvdXRlckhvb2sgfHwgKERhdGFSb3V0ZXJIb29rID0ge30pKTtcbnZhciBEYXRhUm91dGVyU3RhdGVIb29rO1xuKGZ1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyc1wiXSA9IFwidXNlRmV0Y2hlcnNcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xufSkoRGF0YVJvdXRlclN0YXRlSG9vayB8fCAoRGF0YVJvdXRlclN0YXRlSG9vayA9IHt9KSk7XG4vLyBJbnRlcm5hbCBob29rc1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAhc3RhdGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuLy8gRXh0ZXJuYWwgaG9va3Ncbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZWxhdGl2ZSxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUHJvcCAhPT0gdW5kZWZpbmVkID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbG9jYXRpb24sIG5hdmlnYXRlLCBwYXRoLCByZXBsYWNlUHJvcCwgc3RhdGUsIHRhcmdldCwgdG8sIHByZXZlbnRTY3JvbGxSZXNldCwgcmVsYXRpdmUsIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXSk7XG59XG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLCBcIllvdSBjYW5ub3QgdXNlIHRoZSBgdXNlU2VhcmNoUGFyYW1zYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IFwiICsgXCJzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IFwiICsgXCJFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBcIiArIFwiaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuXCIgKyBcIklmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBcIiArIFwiaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IFwiICsgXCJ0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgXCIgKyBcInVzZXIuXCIpIDogdm9pZCAwO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+XG4gIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XG4gIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvbi5zZWFyY2gsIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCksIFtsb2NhdGlvbi5zZWFyY2hdKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0KTtcbiAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gIH0sIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXSk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCIpO1xuICB9XG59XG5sZXQgZmV0Y2hlcklkID0gMDtcbmxldCBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBcIl9fXCIgKyBTdHJpbmcoKytmZXRjaGVySWQpICsgXCJfX1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBjdXJyZW50Um91dGVJZCA9IFVOU0FGRV91c2VSb3V0ZUlkKCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uKCk7XG4gICAgbGV0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIG1ldGhvZCxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGJvZHlcbiAgICB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpO1xuICAgIGlmIChvcHRpb25zLm5hdmlnYXRlID09PSBmYWxzZSkge1xuICAgICAgbGV0IGtleSA9IG9wdGlvbnMuZmV0Y2hlcktleSB8fCBnZXRVbmlxdWVGZXRjaGVySWQoKTtcbiAgICAgIHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdGlvbnMudW5zdGFibGVfZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luYyxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IG9wdGlvbnMudW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXSk7XG59XG4vLyB2NzogRXZlbnR1YWxseSB3ZSBzaG91bGQgZGVwcmVjYXRlIHRoaXMgZW50aXJlbHkgaW4gZmF2b3Igb2YgdXNpbmcgdGhlXG4vLyByb3V0ZXIgbWV0aG9kIGRpcmVjdGx5P1xuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAhcm91dGVDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcbiAgbGV0IHBhdGggPSBfZXh0ZW5kcyh7fSwgdXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7XG4gICAgcmVsYXRpdmVcbiAgfSkpO1xuICAvLyBJZiBubyBhY3Rpb24gd2FzIHNwZWNpZmllZCwgYnJvd3NlcnMgd2lsbCBwZXJzaXN0IGN1cnJlbnQgc2VhcmNoIHBhcmFtc1xuICAvLyB3aGVuIGRldGVybWluaW5nIHRoZSBwYXRoLCBzbyBtYXRjaCB0aGF0IGJlaGF2aW9yXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBpZiAoYWN0aW9uID09IG51bGwpIHtcbiAgICAvLyBTYWZlIHRvIHdyaXRlIHRvIHRoaXMgZGlyZWN0bHkgaGVyZSBzaW5jZSBpZiBhY3Rpb24gd2FzIHVuZGVmaW5lZCwgd2VcbiAgICAvLyB3b3VsZCBoYXZlIGNhbGxlZCB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpIHdoaWNoIHdpbGwgbmV2ZXIgaW5jbHVkZSBhIHNlYXJjaFxuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSBhbnkgaW5jbHVkZWQgP2luZGV4IHBhcmFtXG4gICAgLy8gc2luY2UgaXQgbWlnaHQgbm90IGFwcGx5IHRvIG91ciBjb250ZXh0dWFsIHJvdXRlLiAgV2UgYWRkIGl0IGJhY2sgYmFzZWRcbiAgICAvLyBvbiBtYXRjaC5yb3V0ZS5pbmRleCBiZWxvd1xuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICBpZiAocGFyYW1zLmhhcyhcImluZGV4XCIpICYmIHBhcmFtcy5nZXQoXCJpbmRleFwiKSA9PT0gXCJcIikge1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXJhbXMudG9TdHJpbmcoKSA/IFwiP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgZm9ybSBhY3Rpb24uICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlXG4gIC8vIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZVxuICAvLyBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgYWN0aW9uc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG4vLyBUT0RPOiAodjcpIENoYW5nZSB0aGUgdXNlRmV0Y2hlciBnZW5lcmljIGRlZmF1bHQgZnJvbSBgYW55YCB0byBgdW5rbm93bmBcbi8qKlxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gKi9cbmZ1bmN0aW9uIHVzZUZldGNoZXIoX3RlbXAzKSB7XG4gIHZhciBfcm91dGUkbWF0Y2hlcztcbiAgbGV0IHtcbiAgICBrZXlcbiAgfSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDM7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcik7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlSWQgPSAoX3JvdXRlJG1hdGNoZXMgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGUkbWF0Y2hlcy5yb3V0ZS5pZDtcbiAgIWZldGNoZXJEYXRhID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIShyb3V0ZUlkICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIC8vIEZldGNoZXIga2V5IGhhbmRsaW5nXG4gIC8vIE9LIHRvIGNhbGwgY29uZGl0aW9uYWxseSB0byBmZWF0dXJlIGRldGVjdCBgdXNlSWRgXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICBsZXQgZGVmYXVsdEtleSA9IHVzZUlkSW1wbCA/IHVzZUlkSW1wbCgpIDogXCJcIjtcbiAgbGV0IFtmZXRjaGVyS2V5LCBzZXRGZXRjaGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKGtleSB8fCBkZWZhdWx0S2V5KTtcbiAgaWYgKGtleSAmJiBrZXkgIT09IGZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XG4gIH0gZWxzZSBpZiAoIWZldGNoZXJLZXkpIHtcbiAgICAvLyBXZSB3aWxsIG9ubHkgZmFsbCB0aHJvdWdoIGhlcmUgd2hlbiBgdXNlSWRgIGlzIG5vdCBhdmFpbGFibGVcbiAgICBzZXRGZXRjaGVyS2V5KGdldFVuaXF1ZUZldGNoZXJJZCgpKTtcbiAgfVxuICAvLyBSZWdpc3RyYXRpb24vY2xlYW51cFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBUZWxsIHRoZSByb3V0ZXIgd2UndmUgdW5tb3VudGVkIC0gaWYgdjdfZmV0Y2hlclBlcnNpc3QgaXMgZW5hYmxlZCB0aGlzXG4gICAgICAvLyB3aWxsIG5vdCBkZWxldGUgaW1tZWRpYXRlbHkgYnV0IGluc3RlYWQgcXVldWUgdXAgYSBkZWxldGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBmZXRjaGVyIHJldHVybnMgdG8gYW4gYGlkbGVgIHN0YXRlXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG4gIC8vIEZldGNoZXIgYWRkaXRpb25zXG4gIGxldCBsb2FkID0gUmVhY3QudXNlQ2FsbGJhY2soKGhyZWYsIG9wdHMpID0+IHtcbiAgICAhcm91dGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpO1xuICB9LCBbZmV0Y2hlcktleSwgcm91dGVJZCwgcm91dGVyXSk7XG4gIGxldCBzdWJtaXRJbXBsID0gdXNlU3VibWl0KCk7XG4gIGxldCBzdWJtaXQgPSBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRzKSA9PiB7XG4gICAgc3VibWl0SW1wbCh0YXJnZXQsIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICBmZXRjaGVyS2V5XG4gICAgfSkpO1xuICB9LCBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF0pO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm0sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICAgIGZldGNoZXJLZXk6IGZldGNoZXJLZXksXG4gICAgICAgIHJlZjogcmVmXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgIH1cbiAgICByZXR1cm4gRmV0Y2hlckZvcm07XG4gIH0sIFtmZXRjaGVyS2V5XSk7XG4gIC8vIEV4cG9zZWQgRmV0Y2hlcldpdGhDb21wb25lbnRzXG4gIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGZldGNoZXJLZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgbGV0IGRhdGEgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IF9leHRlbmRzKHtcbiAgICBGb3JtOiBGZXRjaGVyRm9ybSxcbiAgICBzdWJtaXQsXG4gICAgbG9hZFxuICB9LCBmZXRjaGVyLCB7XG4gICAgZGF0YVxuICB9KSwgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIGZldGNoZXIsIGRhdGFdKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGUuZmV0Y2hlcnMuZW50cmllcygpKS5tYXAoX3JlZjExID0+IHtcbiAgICBsZXQgW2tleSwgZmV0Y2hlcl0gPSBfcmVmMTE7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBmZXRjaGVyLCB7XG4gICAgICBrZXlcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcbi8qKlxuICogV2hlbiByZW5kZXJlZCBpbnNpZGUgYSBSb3V0ZXJQcm92aWRlciwgd2lsbCByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbnMgb24gbmF2aWdhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oX3RlbXA0KSB7XG4gIGxldCB7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSA9IF90ZW1wNCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDQ7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCB7XG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcbiAgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gIHVzZVBhZ2VIaWRlKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIkZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IChcIiArIGVycm9yICsgXCIpLlwiKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKSk7XG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkpO1xuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGdldEtleVdpdGhvdXRCYXNlbmFtZSA9IGdldEtleSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIgPyAobG9jYXRpb24sIG1hdGNoZXMpID0+IGdldEtleSggLy8gU3RyaXAgdGhlIGJhc2VuYW1lIHRvIG1hdGNoIHVzZUxvY2F0aW9uKClcbiAgICAgIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSwgbWF0Y2hlcykgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIuZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oc2F2ZWRTY3JvbGxQb3NpdGlvbnMsICgpID0+IHdpbmRvdy5zY3JvbGxZLCBnZXRLZXlXaXRob3V0QmFzZW5hbWUpO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG4gICAgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBFeHBsaWNpdCBmYWxzZSBtZWFucyBkb24ndCBkbyBhbnl0aGluZyAodXNlZCBmb3Igc3VibWlzc2lvbnMpXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkZWNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaGFzaC5zbGljZSgxKSkpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICB9XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLiAgVGhpcyBldmVudCBpcyBiZXR0ZXIgc3VwcG9ydGVkIHRoYW4gYmVmb3JldW5sb2FkIGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB1c2VCbG9ja2VyIHRvIHNob3cgYSB3aW5kb3cuY29uZmlybSBwcm9tcHQgdG8gdXNlcnMgaW5zdGVhZFxuICogb2YgYnVpbGRpbmcgYSBjdXN0b20gVUkgd2l0aCB1c2VCbG9ja2VyLlxuICpcbiAqIFdhcm5pbmc6IFRoaXMgaGFzICphIGxvdCBvZiByb3VnaCBlZGdlcyogYW5kIGJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSAoYW5kXG4gKiB2ZXJ5IGluY29ycmVjdGx5IGluIHNvbWUgY2FzZXMpIGFjcm9zcyBicm93c2VycyBpZiB1c2VyIGNsaWNrIGFkZGl0aW9uXG4gKiBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbnMgd2hpbGUgdGhlIGNvbmZpcm0gaXMgb3Blbi4gIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICovXG5mdW5jdGlvbiB1c2VQcm9tcHQoX3JlZjEyKSB7XG4gIGxldCB7XG4gICAgd2hlbixcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmMTI7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXG4gICAgICAgIC8vIGJldHdlZW4gdGhlIGB3aW5kb3cuaGlzdG9yeWAgcmV2ZXJ0IG5hdmlnYXRpb24gYW5kIHRoZSByZXN1bHQgb2ZcbiAgICAgICAgLy8gYHdpbmRvdy5jb25maXJtYFxuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB2aWV3IHRyYW5zaXRpb24gdG8gdGhlXG4gKiBnaXZlbiBocmVmLiAgWW91IGNhbiB1c2UgdGhpcyB2YWx1ZSB0byByZW5kZXIgQ1NTIGNsYXNzZXMgb3Igdmlld1RyYW5zaXRpb25OYW1lXG4gKiBzdHlsZXMgb250byB5b3VyIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIGhyZWYgVGhlIGRlc3RpbmF0aW9uIGhyZWZcbiAqIEBwYXJhbSBbb3B0cy5yZWxhdGl2ZV0gUmVsYXRpdmUgcm91dGluZyB0eXBlIChcInJvdXRlXCIgfCBcInBhdGhcIilcbiAqL1xuZnVuY3Rpb24gdXNlVmlld1RyYW5zaXRpb25TdGF0ZSh0bywgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGxldCB2dENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gICEodnRDb250ZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgKyBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGUpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlXG4gIH0pO1xuICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcbiAgLy8gVHJhbnNpdGlvbiBpcyBhY3RpdmUgaWYgd2UncmUgZ29pbmcgdG8gb3IgY29taW5nIGZyb20gdGhlIGluZGljYXRlZFxuICAvLyBkZXN0aW5hdGlvbi4gIFRoaXMgZW5zdXJlcyB0aGF0IG90aGVyIFBVU0ggbmF2aWdhdGlvbnMgdGhhdCByZXZlcnNlXG4gIC8vIGFuIGluZGljYXRlZCB0cmFuc2l0aW9uIGFwcGx5LiAgSS5lLiwgb24gdGhlIGxpc3QgdmlldyB5b3UgaGF2ZTpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9kZXRhaWxzLzFcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gSWYgeW91IGNsaWNrIHRoZSBicmVhZGNydW1iIGJhY2sgdG8gdGhlIGxpc3QgdmlldzpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9saXN0XCIgdW5zdGFibGVfdmlld1RyYW5zaXRpb24+XG4gIC8vXG4gIC8vIFdlIHNob3VsZCBhcHBseSB0aGUgdHJhbnNpdGlvbiBiZWNhdXNlIGl0J3MgaW5kaWNhdGVkIGFzIGFjdGl2ZSBnb2luZ1xuICAvLyBmcm9tIC9saXN0IC0+IC9kZXRhaWxzLzEgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgYWN0aXZlIG9uIHRoZSByZXZlcnNlXG4gIC8vIChldmVuIHRob3VnaCB0aGlzIGlzbid0IHN0cmljdGx5IGEgUE9QIHJldmVyc2UpXG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEZvcm0sIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmssIFJvdXRlclByb3ZpZGVyLCBTY3JvbGxSZXN0b3JhdGlvbiwgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsIFZpZXdUcmFuc2l0aW9uQ29udGV4dCBhcyBVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0LCB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsIGNyZWF0ZUhhc2hSb3V0ZXIsIGNyZWF0ZVNlYXJjaFBhcmFtcywgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLCB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LCB1c2VWaWV3VHJhbnNpdGlvblN0YXRlIGFzIHVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGUsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxpbmtDbGlja0hhbmRsZXIsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0RE9NIiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiUm91dGVyIiwiVU5TQUZFX3VzZVJvdXRlc0ltcGwiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJ1c2VIcmVmIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlTG9jYXRpb24iLCJ1c2VOYXZpZ2F0ZSIsImNyZWF0ZVBhdGgiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInVzZUJsb2NrZXIiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkF3YWl0IiwiTWVtb3J5Um91dGVyIiwiTmF2aWdhdGUiLCJOYXZpZ2F0aW9uVHlwZSIsIk91dGxldCIsIlJvdXRlIiwiUm91dGVzIiwiVU5TQUZFX0xvY2F0aW9uQ29udGV4dCIsImNyZWF0ZU1lbW9yeVJvdXRlciIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsImNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyIsImRlZmVyIiwiZ2VuZXJhdGVQYXRoIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJqc29uIiwibWF0Y2hQYXRoIiwibWF0Y2hSb3V0ZXMiLCJwYXJzZVBhdGgiLCJyZWRpcmVjdCIsInJlZGlyZWN0RG9jdW1lbnQiLCJyZW5kZXJNYXRjaGVzIiwicmVzb2x2ZVBhdGgiLCJ1c2VBY3Rpb25EYXRhIiwidXNlQXN5bmNFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJ1c2VMb2FkZXJEYXRhIiwidXNlTWF0Y2giLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsInVzZU91dGxldCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VQYXJhbXMiLCJ1c2VSZXZhbGlkYXRvciIsInVzZVJvdXRlRXJyb3IiLCJ1c2VSb3V0ZUxvYWRlckRhdGEiLCJ1c2VSb3V0ZXMiLCJzdHJpcEJhc2VuYW1lIiwiVU5TQUZFX3dhcm5pbmciLCJjcmVhdGVSb3V0ZXIiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX2ludmFyaWFudCIsImpvaW5QYXRocyIsIklETEVfRkVUQ0hFUiIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJkZWZhdWx0TWV0aG9kIiwiZGVmYXVsdEVuY1R5cGUiLCJpc0h0bWxFbGVtZW50Iiwib2JqZWN0IiwidGFnTmFtZSIsImlzQnV0dG9uRWxlbWVudCIsInRvTG93ZXJDYXNlIiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsImJ1dHRvbiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImluaXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2UiLCJtZW1vIiwidmFsdWUiLCJjb25jYXQiLCJtYXAiLCJ2IiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwiXyIsImhhcyIsImdldEFsbCIsImFwcGVuZCIsIl9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyIiwiaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCIsIkZvcm1EYXRhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZSIsInN1cHBvcnRlZEZvcm1FbmNUeXBlcyIsIlNldCIsImdldEZvcm1FbmNUeXBlIiwiZW5jVHlwZSIsImdldEZvcm1TdWJtaXNzaW9uSW5mbyIsImJhc2VuYW1lIiwibWV0aG9kIiwiYWN0aW9uIiwiZm9ybURhdGEiLCJib2R5IiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInR5cGUiLCJmb3JtIiwiRXJyb3IiLCJuYW1lIiwicHJlZml4IiwidW5kZWZpbmVkIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9leGNsdWRlZDMiLCJSRUFDVF9ST1VURVJfVkVSU0lPTiIsIndpbmRvdyIsIl9fcmVhY3RSb3V0ZXJWZXJzaW9uIiwiY3JlYXRlQnJvd3NlclJvdXRlciIsInJvdXRlcyIsIm9wdHMiLCJmdXR1cmUiLCJ2N19wcmVwZW5kQmFzZW5hbWUiLCJoaXN0b3J5IiwiaHlkcmF0aW9uRGF0YSIsInBhcnNlSHlkcmF0aW9uRGF0YSIsIm1hcFJvdXRlUHJvcGVydGllcyIsImluaXRpYWxpemUiLCJjcmVhdGVIYXNoUm91dGVyIiwiX3dpbmRvdyIsInN0YXRlIiwiX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhIiwiZXJyb3JzIiwiZGVzZXJpYWxpemVFcnJvcnMiLCJlbnRyaWVzIiwic2VyaWFsaXplZCIsInZhbCIsIl9fdHlwZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwiaW50ZXJuYWwiLCJfX3N1YlR5cGUiLCJFcnJvckNvbnN0cnVjdG9yIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJWaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiaXNUcmFuc2l0aW9uaW5nIiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwiRmV0Y2hlcnNDb250ZXh0IiwiTWFwIiwiU1RBUlRfVFJBTlNJVElPTiIsInN0YXJ0VHJhbnNpdGlvbkltcGwiLCJGTFVTSF9TWU5DIiwiZmx1c2hTeW5jSW1wbCIsIlVTRV9JRCIsInVzZUlkSW1wbCIsInN0YXJ0VHJhbnNpdGlvblNhZmUiLCJjYiIsImZsdXNoU3luY1NhZmUiLCJEZWZlcnJlZCIsImNvbnN0cnVjdG9yIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhc29uIiwiUm91dGVyUHJvdmlkZXIiLCJfcmVmIiwiZmFsbGJhY2tFbGVtZW50Iiwicm91dGVyIiwic2V0U3RhdGVJbXBsIiwidXNlU3RhdGUiLCJwZW5kaW5nU3RhdGUiLCJzZXRQZW5kaW5nU3RhdGUiLCJ2dENvbnRleHQiLCJzZXRWdENvbnRleHQiLCJyZW5kZXJEZmQiLCJzZXRSZW5kZXJEZmQiLCJ0cmFuc2l0aW9uIiwic2V0VHJhbnNpdGlvbiIsImludGVycnVwdGlvbiIsInNldEludGVycnVwdGlvbiIsImZldGNoZXJEYXRhIiwidXNlUmVmIiwidjdfc3RhcnRUcmFuc2l0aW9uIiwib3B0SW5TdGFydFRyYW5zaXRpb24iLCJ1c2VDYWxsYmFjayIsInNldFN0YXRlIiwibmV3U3RhdGUiLCJfcmVmMiIsImRlbGV0ZWRGZXRjaGVycyIsInVuc3RhYmxlX2ZsdXNoU3luYyIsImZsdXNoU3luYyIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0cyIsInZpZXdUcmFuc2l0aW9uT3B0cyIsImN1cnJlbnQiLCJkZWxldGUiLCJmZXRjaGVycyIsImZldGNoZXIiLCJzZXQiLCJpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUiLCJzdGFydFZpZXdUcmFuc2l0aW9uIiwic2tpcFRyYW5zaXRpb24iLCJjdXJyZW50TG9jYXRpb24iLCJuZXh0TG9jYXRpb24iLCJ0IiwiZmluaXNoZWQiLCJmaW5hbGx5IiwidXNlTGF5b3V0RWZmZWN0Iiwic3Vic2NyaWJlIiwidXNlRWZmZWN0IiwicmVuZGVyUHJvbWlzZSIsImxvY2F0aW9uIiwidjdfcGFydGlhbEh5ZHJhdGlvbiIsIm5hdmlnYXRvciIsInVzZU1lbW8iLCJjcmVhdGVIcmVmIiwiZW5jb2RlTG9jYXRpb24iLCJnbyIsIm4iLCJuYXZpZ2F0ZSIsInB1c2giLCJ0byIsInByZXZlbnRTY3JvbGxSZXNldCIsInJlcGxhY2UiLCJkYXRhUm91dGVyQ29udGV4dCIsInN0YXRpYyIsIkZyYWdtZW50IiwiUHJvdmlkZXIiLCJuYXZpZ2F0aW9uVHlwZSIsImhpc3RvcnlBY3Rpb24iLCJ2N19yZWxhdGl2ZVNwbGF0UGF0aCIsImluaXRpYWxpemVkIiwiRGF0YVJvdXRlcyIsIl9yZWYzIiwiQnJvd3NlclJvdXRlciIsIl9yZWY0IiwiY2hpbGRyZW4iLCJoaXN0b3J5UmVmIiwidjVDb21wYXQiLCJsaXN0ZW4iLCJIYXNoUm91dGVyIiwiX3JlZjUiLCJIaXN0b3J5Um91dGVyIiwiX3JlZjYiLCJpc0Jyb3dzZXIiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwiX3JlZjciLCJyZWYiLCJvbkNsaWNrIiwicmVsYXRpdmUiLCJyZWxvYWREb2N1bWVudCIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uIiwicmVzdCIsInVzZUNvbnRleHQiLCJhYnNvbHV0ZUhyZWYiLCJpc0V4dGVybmFsIiwidGVzdCIsImN1cnJlbnRVcmwiLCJVUkwiLCJocmVmIiwidGFyZ2V0VXJsIiwic3RhcnRzV2l0aCIsInByb3RvY29sIiwicGF0aCIsInBhdGhuYW1lIiwib3JpZ2luIiwic2VhcmNoIiwiaGFzaCIsImludGVybmFsT25DbGljayIsInVzZUxpbmtDbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJOYXZMaW5rIiwiTmF2TGlua1dpdGhSZWYiLCJfcmVmOCIsImFyaWFDdXJyZW50UHJvcCIsImNhc2VTZW5zaXRpdmUiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwiZW5kIiwic3R5bGUiLCJzdHlsZVByb3AiLCJyb3V0ZXJTdGF0ZSIsInVzZVZpZXdUcmFuc2l0aW9uU3RhdGUiLCJ0b1BhdGhuYW1lIiwibG9jYXRpb25QYXRobmFtZSIsIm5leHRMb2NhdGlvblBhdGhuYW1lIiwibmF2aWdhdGlvbiIsImVuZFNsYXNoUG9zaXRpb24iLCJlbmRzV2l0aCIsImlzQWN0aXZlIiwiY2hhckF0IiwiaXNQZW5kaW5nIiwicmVuZGVyUHJvcHMiLCJhcmlhQ3VycmVudCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiRm9ybSIsIl9yZWY5IiwiZm9yd2FyZGVkUmVmIiwiZmV0Y2hlcktleSIsIm9uU3VibWl0IiwicHJvcHMiLCJzdWJtaXQiLCJ1c2VTdWJtaXQiLCJmb3JtQWN0aW9uIiwidXNlRm9ybUFjdGlvbiIsImZvcm1NZXRob2QiLCJzdWJtaXRIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJzdWJtaXR0ZXIiLCJuYXRpdmVFdmVudCIsInN1Ym1pdE1ldGhvZCIsImN1cnJlbnRUYXJnZXQiLCJTY3JvbGxSZXN0b3JhdGlvbiIsIl9yZWYxMCIsImdldEtleSIsInN0b3JhZ2VLZXkiLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwiX3RlbXAiLCJyZXBsYWNlUHJvcCIsInVzZVNlYXJjaFBhcmFtcyIsImRlZmF1bHRJbml0IiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsImhhc1NldFNlYXJjaFBhcmFtc1JlZiIsInNldFNlYXJjaFBhcmFtcyIsIm5leHRJbml0IiwibmF2aWdhdGVPcHRpb25zIiwibmV3U2VhcmNoUGFyYW1zIiwidmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbiIsImZldGNoZXJJZCIsImdldFVuaXF1ZUZldGNoZXJJZCIsIlN0cmluZyIsIlVzZVN1Ym1pdCIsImN1cnJlbnRSb3V0ZUlkIiwib3B0aW9ucyIsImZldGNoIiwiZm9ybUVuY1R5cGUiLCJmcm9tUm91dGVJZCIsIl90ZW1wMiIsInJvdXRlQ29udGV4dCIsIm1hdGNoIiwibWF0Y2hlcyIsInNsaWNlIiwicGFyYW1zIiwiZ2V0IiwidG9TdHJpbmciLCJyb3V0ZSIsImluZGV4IiwidXNlRmV0Y2hlciIsIl90ZW1wMyIsIl9yb3V0ZSRtYXRjaGVzIiwiVXNlRmV0Y2hlciIsInJvdXRlSWQiLCJpZCIsImRlZmF1bHRLZXkiLCJzZXRGZXRjaGVyS2V5IiwiZ2V0RmV0Y2hlciIsImRlbGV0ZUZldGNoZXIiLCJsb2FkIiwic3VibWl0SW1wbCIsIkZldGNoZXJGb3JtIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwidXNlRmV0Y2hlcnMiLCJVc2VGZXRjaGVycyIsImZyb20iLCJfcmVmMTEiLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsIl90ZW1wNCIsIlVzZVNjcm9sbFJlc3RvcmF0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJ1c2VQYWdlSGlkZSIsInNjcm9sbFkiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5Iiwic2Vzc2lvblBvc2l0aW9ucyIsImdldEl0ZW0iLCJwYXJzZSIsImdldEtleVdpdGhvdXRCYXNlbmFtZSIsImRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwic2Nyb2xsVG8iLCJlbCIsImdldEVsZW1lbnRCeUlkIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VCZWZvcmVVbmxvYWQiLCJjYWxsYmFjayIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVByb21wdCIsIl9yZWYxMiIsIndoZW4iLCJibG9ja2VyIiwicHJvY2VlZCIsImNvbmZpcm0iLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJjdXJyZW50UGF0aCIsIm5leHRQYXRoIiwiVU5TQUZFX0ZldGNoZXJzQ29udGV4dCIsIlVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyIiwidW5zdGFibGVfdXNlUHJvbXB0IiwidW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router-dom/dist/index.js\n");

/***/ })

};
;