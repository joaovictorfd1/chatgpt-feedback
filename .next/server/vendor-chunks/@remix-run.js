"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@remix-run";
exports.ids = ["vendor-chunks/@remix-run"];
exports.modules = {

/***/ "(ssr)/./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_getResolveToMatches: () => (/* binding */ getResolveToMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\n * @remix-run/router v1.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = Action.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = Action.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = Action.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = Action.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname, search, hash } = window1.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window1.location.hash.substr(1));\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    let location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    let { pathname = \"/\", search = \"\", hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { window: window1 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = Action.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : createPath(to);\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            let indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        safelyDecodeURI(pathname));\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo, _ref, index)=>{\n        let { paramName, isOptional } = _ref;\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo[paramName] = undefined;\n        } else {\n            memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n        }\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    } catch (error) {\n        warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n    let pathMatches = getPathContributingMatches(matches);\n    // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n    // match so we include splat values for \".\" links.  See:\n    // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n    if (v7_relativeSplatPath) {\n        return pathMatches.map((match, idx)=>idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n    }\n    return pathMatches.map((match)=>match.pathnameBase);\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        // With relative=\"route\" (the default), each leading .. segment means\n        // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n        // difference from how <a href> works and a major reason we call this a\n        // \"to\" value instead of a \"href\".\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers\n    }));\n};\nclass AbortedDeferredError extends Error {\n}\nclass DeferredData {\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) {\n                        resolve(aborted);\n                    }\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref3)=>{\n            let [key, value] = _ref3;\n            return Object.assign(acc, {\n                [key]: unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n}\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nconst defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers\n    }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */ class ErrorResponseImpl {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else {\n            this.data = data;\n        }\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\n    \"get\",\n    ...validMutationMethodsArr\n];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : undefined;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    } else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = _extends({\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: false,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized;\n    let hasLazyRoutes = initialMatches.some((m)=>m.route.lazy);\n    let hasLoaders = initialMatches.some((m)=>m.route.loader);\n    if (hasLazyRoutes) {\n        // All initialMatches need to be loaded before we're ready.  If we have lazy\n        // functions around still then we'll need to run them in initialize()\n        initialized = false;\n    } else if (!hasLoaders) {\n        // If we've got no loaders to run, then we're good to go\n        initialized = true;\n    } else if (future.v7_partialHydration) {\n        // If partial hydration is enabled, we're initialized so long as we were\n        // provided with hydrationData for every route with a loader, and no loaders\n        // were marked for explicit hydration\n        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n        let errors = init.hydrationData ? init.hydrationData.errors : null;\n        initialized = initialMatches.every((m)=>m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined));\n    } else {\n        // Without partial hydration - we're initialized if we were provided any\n        // hydrationData - which is expected to be complete\n        initialized = init.hydrationData != null;\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // Should the current navigation enable document.startViewTransition?\n    let pendingViewTransitionEnabled = false;\n    // Store applied view transitions so we can apply them on POP\n    let appliedViewTransitions = new Map();\n    // Cleanup function for persisting applied transitions to sessionStorage\n    let removePageHideEventListener = null;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Ref-count mounted fetchers so we know when it's ok to clean them up\n    let activeFetchers = new Map();\n    // Fetchers that have requested a delete when using v7_fetcherPersist,\n    // they'll be officially removed after they return to idle\n    let deletedFetchers = new Set();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location, delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser) {\n            // FIXME: This feels gross.  How can we cleanup the lines between\n            // scrollRestoration/appliedTransitions persistance?\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state = _extends({}, state, newState);\n        // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n        // can be removed\n        let completedFetchers = [];\n        let deletedFetchersKeys = [];\n        if (future.v7_fetcherPersist) {\n            state.fetchers.forEach((fetcher, key)=>{\n                if (fetcher.state === \"idle\") {\n                    if (deletedFetchers.has(key)) {\n                        // Unmounted from the UI and can be totally removed\n                        deletedFetchersKeys.push(key);\n                    } else {\n                        // Returned to idle but still mounted in the UI, so semi-remains for\n                        // revalidations and such\n                        completedFetchers.push(key);\n                    }\n                }\n            });\n        }\n        // Iterate over a local copy so that if flushSync is used and we end up\n        // removing and adding a new subscriber due to the useCallback dependencies,\n        // we don't get ourselves into a loop calling the new subscriber immediately\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: deletedFetchersKeys,\n                unstable_viewTransitionOpts: opts.viewTransitionOpts,\n                unstable_flushSync: opts.flushSync === true\n            }));\n        // Remove idle fetchers from state since we only care about in-flight fetchers.\n        if (future.v7_fetcherPersist) {\n            completedFetchers.forEach((key)=>state.fetchers.delete(key));\n            deletedFetchersKeys.forEach((key)=>deleteFetcher(key));\n        }\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState, _temp) {\n        var _location$state, _location$state2;\n        let { flushSync } = _temp === void 0 ? {} : _temp;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        } else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        // On POP, enable transitions if they were enabled on the original navigation\n        if (pendingAction === Action.Pop) {\n            // Forward takes precedence so they behave like the original navigation\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                // If we don't have a previous forward nav, assume we're popping back to\n                // the new location and enable if that location previously enabled\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            // Store the applied transition on PUSH/REPLACE\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState(_extends({}, newState, {\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }), {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = Action.Push;\n        if (userReplace === true) {\n            historyAction = Action.Replace;\n        } else if (userReplace === false) ;\n        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            // By default on submissions to the current location we REPLACE so that\n            // users don't have to double-click the back button to get to the prior\n            // location.  If the user redirects to a different location from the\n            // action/loader this will be ignored and the redirect will be a PUSH\n            historyAction = Action.Replace;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.unstable_viewTransition,\n            flushSync\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) {\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It's not really\n            // different from an actionError in that sense.\n            pendingError = {\n                [findNearestBoundary(matches).route.id]: opts.pendingError\n            };\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionOutput.shortCircuited) {\n                return;\n            }\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited, loaderData, errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n        if (shortCircuited) {\n            return;\n        }\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, _extends({\n            matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData,\n            errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: ResultType.error,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) {\n                replace = opts.replace;\n            } else {\n                // If the user didn't explicity indicate replace behavior, replace if\n                // we redirected to the exact same location we're currently at to avoid\n                // double back-buttons\n                replace = result.location === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(state, result, {\n                submission,\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n                pendingAction = Action.Push;\n            }\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if (isDeferredResult(result)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        // If we have partialHydration enabled, then don't update the state for the\n        // initial data load since iot's not a \"navigation\"\n        if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState(_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n            }\n            if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                    activeDeferreds.delete(routeId);\n                }\n            });\n        });\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return _extends({\n            loaderData,\n            errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n        // or redirects processed for unmounted fetchers so we just revert them to\n        // idle\n        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            }\n        // Let SuccessResult's fall through for revalidation\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    // A new navigation was kicked off after our action started, so that\n                    // should take precedence over this redirect navigation.  We already\n                    // set isRevalidationRequired so all loaders for the new route should\n                    // fire unless opted out via shouldRevalidate\n                    updateFetcherState(key, getDoneFetcher(undefined));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(state, actionResult, {\n                        fetcherSubmission: submission\n                    });\n                }\n            }\n            // Process any non-redirect errors thrown\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        if (isDeferredResult(actionResult)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n            }\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n            flushSync\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if (isDeferredResult(result)) {\n            result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n        }\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        // We don't want errors bubbling up or redirects followed for unmounted\n        // fetchers, so short circuit here if it was removed from the UI\n        if (deletedFetchers.has(key)) {\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return;\n        }\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp2) {\n        let { submission, fetcherSubmission, replace } = _temp2 === void 0 ? {} : _temp2;\n        if (redirect.revalidate) {\n            isRevalidationRequired = true;\n        }\n        let redirectLocation = createLocation(state.location, redirect.location, {\n            _isRedirect: true\n        });\n        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n        if (isBrowser) {\n            let isDocumentReload = false;\n            if (redirect.reloadDocument) {\n                // Hard reload if the response contained X-Remix-Reload-Document\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                const url = init.history.createURL(redirect.location);\n                isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n                url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace) {\n                    routerWindow.location.replace(redirect.location);\n                } else {\n                    routerWindow.location.assign(redirect.location);\n                }\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                submission: _extends({}, activeSubmission, {\n                    formAction: redirect.location\n                }),\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        } else {\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) {\n                    return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n                } else {\n                    let error = {\n                        type: ResultType.error,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results,\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function updateFetcherState(key, fetcher, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        if (future.v7_fetcherPersist) {\n            activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n            // If this fetcher was previously marked for deletion, unmark it since we\n            // have a new instance\n            if (deletedFetchers.has(key)) {\n                deletedFetchers.delete(key);\n            }\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        deletedFetchers.delete(key);\n        state.fetchers.delete(key);\n    }\n    function deleteFetcherAndUpdateState(key) {\n        if (future.v7_fetcherPersist) {\n            let count = (activeFetchers.get(key) || 0) - 1;\n            if (count <= 0) {\n                activeFetchers.delete(key);\n                deletedFetchers.add(key);\n            } else {\n                activeFetchers.set(key, count);\n            }\n        } else {\n            deleteFetcher(key);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        let { currentLocation, nextLocation, historyAction } = _ref2;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: deleteFetcherAndUpdateState,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    } else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Config driven behavior flags\n    let future = _extends({\n        v7_relativeSplatPath: false,\n        v7_throwAbortReason: false\n    }, opts ? opts.future : null);\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp3) {\n        let { requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if (isResponse(result)) {\n            return result;\n        }\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return _extends({\n            location,\n            basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp4) {\n        let { routeId, requestContext } = _temp4 === void 0 ? {} : _temp4;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            // This should never hit I don't think?\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) {\n            // If we got back result.errors, that means the loader/action threw\n            // _something_ that wasn't a Response, but it's not guaranteed/required\n            // to be an `instanceof Error` either, so we have to use throw here to\n            // preserve the \"error\" state outside of queryImpl.\n            throw error;\n        }\n        // Pick off the right state value to return\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return isResponse(result) ? result : _extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if (isQueryRouteResponse(e)) {\n                if (e.type === ResultType.error) {\n                    throw e.response;\n                }\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                isStaticRequest: true,\n                isRouteRequest,\n                requestContext\n            });\n            if (request.signal.aborted) {\n                throwStaticHandlerAbortedError(request, isRouteRequest, future);\n            }\n        }\n        if (isRedirectResult(result)) {\n            // Uhhhh - this should never happen, we should always throw these from\n            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n            // can get back on the \"throw all redirect responses\" train here should\n            // this ever happen :/\n            throw new Response(null, {\n                status: result.status,\n                headers: {\n                    Location: result.location\n                }\n            });\n        }\n        if (isDeferredResult(result)) {\n            let error = getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return _extends({}, context, {\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: _extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return _extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: _extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n        }\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) {\n            return {\n                matches,\n                // Add a null for all matched routes for proper revalidation on the client\n                loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                        [m.route.id]: null\n                    }), {}),\n                errors: pendingActionError || null,\n                statusCode: 200,\n                loaderHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                    isStaticRequest: true,\n                    isRouteRequest,\n                    requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            throwStaticHandlerAbortedError(request, isRouteRequest, future);\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n            }\n        });\n        return _extends({}, context, {\n            matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    let newContext = _extends({}, context, {\n        statusCode: isRouteErrorResponse(error) ? error.status : 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest, future) {\n    if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n        throw request.signal.reason;\n    }\n    let method = isRouteRequest ? \"queryRoute\" : \"query\";\n    throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref3)=>{\n                let [name, value] = _ref3;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        let { route } = match;\n        if (route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (route.loader == null) {\n            return false;\n        }\n        if (isInitialLoad) {\n            if (route.loader.hydrate) {\n                return true;\n            }\n            return state.loaderData[route.id] === undefined && // Don't re-run if the loader ran and threw an error\n            (!state.errors || state.errors[route.id] === undefined);\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate:\n        //  - on initial load (shouldn't be any fetchers then anyway)\n        //  - if fetcher won't be present in the subsequent render\n        //    - no longer matches the URL (v7_fetcherPersist=false)\n        //    - was unmounted but persisted due to v7_fetcherPersist=true\n        if (isInitialLoad || !matches.some((m)=>m.route.id === f.routeId) || deletedFetchers.has(key)) {\n            return;\n        }\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        } else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        } else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) {\n        return;\n    }\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) {\n        return;\n    }\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n        }\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let handlerError;\n                let values = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                if (handlerError) {\n                    throw handlerError;\n                }\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) {\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = await runHandler(handler);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    // lazy() route has no loader to run.  Short circuit here so we don't\n                    // hit the invariant below that errors on returning undefined.\n                    return {\n                        type: ResultType.data,\n                        data: undefined\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n        invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    if (isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if (redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!ABSOLUTE_URL_REGEX.test(location)) {\n                location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n            } else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = stripBasename(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) {\n                    location = url.pathname + url.search + url.hash;\n                }\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: ResultType.redirect,\n                status,\n                location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) {\n            let queryRouteResponse = {\n                type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                response: result\n            };\n            throw queryRouteResponse;\n        }\n        let data;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            // Check between word boundaries instead of startsWith() due to the last\n            // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data = null;\n                } else {\n                    data = await result.json();\n                }\n            } else {\n                data = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n        if (resultType === ResultType.error) {\n            return {\n                type: resultType,\n                error: new ErrorResponseImpl(status, result.statusText, data),\n                headers: result.headers\n            };\n        }\n        return {\n            type: ResultType.data,\n            data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === ResultType.error) {\n        return {\n            type: resultType,\n            error: result\n        };\n    }\n    if (isDeferredData(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData, errors } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key, match, controller } = revalidatingFetchers[index];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            continue;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, {\n                    [boundaryMatch.route.id]: result.error\n                });\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = _extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        } else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, _temp5) {\n    let { pathname, routeId, method, type } = _temp5 === void 0 ? {} : _temp5;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (method) {\n            errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    } else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) {\n            continue;\n        }\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) {\n                    results[index] = result || results[index];\n                }\n            });\n        }\n    }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) {\n        unwrap = false;\n    }\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) {\n        return;\n    }\n    if (unwrap) {\n        try {\n            return {\n                type: ResultType.data,\n                data: result.deferredData.unwrappedData\n            };\n        } catch (e) {\n            // Handle any TrackedPromise._error values encountered while unwrapping\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n    }\n    return {\n        type: ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json: undefined,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: undefined,\n            text: undefined\n        };\n    } else if (json !== undefined) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {\n    // no-op, use default empty object\n    }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n        }\n    }\n}\n//#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0E7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQ3pCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLGdGQUFnRjtBQUNoRiw2QkFBNkI7QUFDN0IsZ0ZBQWdGO0FBQ2hGOztDQUVDLEdBQ0QsSUFBSVE7QUFDSCxVQUFVQSxNQUFNO0lBQ2Y7Ozs7OztHQU1DLEdBQ0RBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEI7Ozs7R0FJQyxHQUNEQSxNQUFNLENBQUMsT0FBTyxHQUFHO0lBQ2pCOzs7R0FHQyxHQUNEQSxNQUFNLENBQUMsVUFBVSxHQUFHO0FBQ3RCLEdBQUdBLFVBQVdBLENBQUFBLFNBQVMsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0I7QUFDMUI7OztDQUdDLEdBQ0QsU0FBU0Msb0JBQW9CQyxPQUFPO0lBQ2xDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLElBQUksRUFDRkMsaUJBQWlCO1FBQUM7S0FBSSxFQUN0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LENBQUNuVjtRQUN0RCxJQUFJaVYsa0JBQWtCO1lBQ3BCLElBQUl6YSxPQUFPNU4sS0FBS29rQixLQUFLLENBQUNpRTtZQUN0QixLQUFLLElBQUksQ0FBQ3pYLEdBQUdELEVBQUUsSUFBSXJULE9BQU9vQixPQUFPLENBQUNrUCxRQUFRLENBQUMsR0FBSTtnQkFDN0MsSUFBSStDLEtBQUtoQyxNQUFNQyxPQUFPLENBQUMrQixJQUFJO29CQUN6QnlYLFlBQVlqYSxHQUFHLENBQUN5QyxHQUFHLElBQUk5TCxJQUFJNkwsS0FBSyxFQUFFO2dCQUNwQztZQUNGO1FBQ0Y7SUFDRixFQUFFLE9BQU92TixHQUFHO0lBQ1Ysa0NBQWtDO0lBQ3BDO0FBQ0Y7QUFDQSxTQUFTd1UsMEJBQTBCdVEsT0FBTyxFQUFFQyxXQUFXO0lBQ3JELElBQUlBLFlBQVlyWCxJQUFJLEdBQUcsR0FBRztRQUN4QixJQUFJbkQsT0FBTyxDQUFDO1FBQ1osS0FBSyxJQUFJLENBQUNnRCxHQUFHRCxFQUFFLElBQUl5WCxZQUFhO1lBQzlCeGEsSUFBSSxDQUFDZ0QsRUFBRSxHQUFHO21CQUFJRDthQUFFO1FBQ2xCO1FBQ0EsSUFBSTtZQUNGd1gsUUFBUUcsY0FBYyxDQUFDRSxPQUFPLENBQUNwVix5QkFBeUJwVCxLQUFLQyxTQUFTLENBQUMyTjtRQUN6RSxFQUFFLE9BQU90SixPQUFPO1lBQ2R4RSxRQUFRLE9BQU8sZ0VBQWdFd0UsUUFBUTtRQUN6RjtJQUNGO0FBQ0Y7QUFDQSxZQUFZO0FBRTh2QixDQUMxd0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGdwdC1mZWVkYmFjay8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz81MDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJlbWl4LXJ1bi9yb3V0ZXIgdjEuMTUuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xudmFyIEFjdGlvbjtcbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgbGV0IHtcbiAgICBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIHY1Q29tcGF0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKGVudHJ5LCB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWQpKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUsIGtleSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLCB0bywgc3RhdGUsIGtleSk7XG4gICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLCBcInJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogXCIgKyBKU09OLnN0cmluZ2lmeSh0bykpO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGE6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFwiXCIsIHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0sXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLCBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3csIHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVCcm93c2VyTG9jYXRpb24sIGNyZWF0ZUJyb3dzZXJIcmVmLCBudWxsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIlxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcbiAgICAvLyBIYXNoIFVSTCBzaG91bGQgYWx3YXlzIGhhdmUgYSBsZWFkaW5nIC8ganVzdCBsaWtlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIC8vIGRvZXMsIHNvIGlmIGFuIGFwcCBlbmRzIHVwIGF0IGEgcm91dGUgbGlrZSAvI3NvbWV0aGluZyB0aGVuIHdlIGFkZCBhXG4gICAgLy8gbGVhZGluZyBzbGFzaCBzbyBhbGwgb2Ygb3VyIHBhdGgtbWF0Y2hpbmcgYmVoYXZlcyB0aGUgc2FtZSBhcyBpZiBpdCB3b3VsZFxuICAgIC8vIGluIGEgYnJvd3NlciByb3V0ZXIuICBUaGlzIGlzIHBhcnRpY3VsYXJseSBpbXBvcnRhbnQgd2hlbiB0aGVyZSBleGlzdHMgYVxuICAgIC8vIHJvb3Qgc3BsYXQgcm91dGUgKDxSb3V0ZSBwYXRoPVwiKlwiPikgc2luY2UgdGhhdCBtYXRjaGVzIGludGVybmFsbHkgYWdhaW5zdFxuICAgIC8vIFwiLypcIiBhbmQgd2UnZCBleHBlY3QgLyNzb21ldGhpbmcgdG8gNDA0IGluIGEgaGFzaCByb3V0ZXIgYXBwLlxuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcIlwiLCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9LFxuICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93LCB0bykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIik7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVIYXNoTG9jYXRpb24sIGNyZWF0ZUhhc2hIcmVmLCB2YWxpZGF0ZUhhc2hMb2NhdGlvbiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXG4gKiBGb3IgYnJvd3Nlci1iYXNlZCBoaXN0b3JpZXMsIHdlIGNvbWJpbmUgdGhlIHN0YXRlIGFuZCBrZXkgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlLCBrZXkpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IG51bGw7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gX2V4dGVuZHMoe1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiXG4gIH0sIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfSk7XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IF9yZWY7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIikgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCB7XG4gICAgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgdjVDb21wYXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcbiAgLy8gdXNlciBjYWxsZWQgaGlzdG9yeS5wdXNoU3RhdGUgb3IgaGlzdG9yeS5yZXBsYWNlU3RhdGUgZGlyZWN0bHksIGluIHdoaWNoXG4gIC8vIGNhc2Ugd2Ugc2hvdWxkIGxvZyBhIHdhcm5pbmcgYXMgaXQgd2lsbCByZXN1bHQgaW4gYnVncy5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7XG4gICAgICBpZHg6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6IFwiICsgaHJlZik7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbnZhciBSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XG4gIFJlc3VsdFR5cGVbXCJkYXRhXCJdID0gXCJkYXRhXCI7XG4gIFJlc3VsdFR5cGVbXCJkZWZlcnJlZFwiXSA9IFwiZGVmZXJyZWRcIjtcbiAgUmVzdWx0VHlwZVtcInJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xuICBSZXN1bHRUeXBlW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShSZXN1bHRUeXBlIHx8IChSZXN1bHRUeXBlID0ge30pKTtcbmNvbnN0IGltbXV0YWJsZVJvdXRlS2V5cyA9IG5ldyBTZXQoW1wibGF6eVwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJwYXRoXCIsIFwiaWRcIiwgXCJpbmRleFwiLCBcImNoaWxkcmVuXCJdKTtcbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3NhcnksIHNvIHdlIGFyZSB3b3JraW5nXG4vLyBzb2xlbHkgd2l0aCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCdzIHdpdGhpbiB0aGUgUm91dGVyXG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCBwYXJlbnRQYXRoLCBtYW5pZmVzdCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGlmIChtYW5pZmVzdCA9PT0gdm9pZCAwKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgfVxuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChyb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sIFwiQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVcIik7XG4gICAgaW52YXJpYW50KCFtYW5pZmVzdFtpZF0sIFwiRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuICBSb3V0ZSBcIiArIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCIpO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGUuY2hpbGRyZW4sIG1hcFJvdXRlUHJvcGVydGllcywgdHJlZVBhdGgsIG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IHZvaWQgMCkge1xuICAgIGJhc2VuYW1lID0gXCIvXCI7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSxcbiAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgIHNhZmVseURlY29kZVVSSShwYXRobmFtZSkpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHtcbiAgICByb3V0ZSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXNcbiAgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcywgcGFyZW50c01ldGEsIHBhcmVudFBhdGgpIHtcbiAgaWYgKGJyYW5jaGVzID09PSB2b2lkIDApIHtcbiAgICBicmFuY2hlcyA9IFtdO1xuICB9XG4gIGlmIChwYXJlbnRzTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50c01ldGEgPSBbXTtcbiAgfVxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XG4gIH1cbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIHJlbGF0aXZlUGF0aCkgPT4ge1xuICAgIGxldCBtZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLCBcIkFic29sdXRlIHJvdXRlIHBhdGggXFxcIlwiICsgbWV0YS5yZWxhdGl2ZVBhdGggKyBcIlxcXCIgbmVzdGVkIHVuZGVyIHBhdGggXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBcIikgKyBcIm11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuXCIpO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLCBcIkluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBcIiArIChcImFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIuXCIpKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIHZhciBfcm91dGUkcGF0aDtcbiAgICAvLyBjb2Fyc2UtZ3JhaW4gY2hlY2sgZm9yIG9wdGlvbmFsIHBhcmFtc1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICEoKF9yb3V0ZSRwYXRoID0gcm91dGUucGF0aCkgIT0gbnVsbCAmJiBfcm91dGUkcGF0aC5pbmNsdWRlcyhcIj9cIikpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbi8qKlxuICogQ29tcHV0ZXMgYWxsIGNvbWJpbmF0aW9ucyBvZiBvcHRpb25hbCBwYXRoIHNlZ21lbnRzIGZvciBhIGdpdmVuIHBhdGgsXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGAvb25lLzp0d28/L3RocmVlLzpmb3VyPy86Zml2ZT9gIGV4cGxvZGVzIHRvOlxuICogLSBgL29uZS90aHJlZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91ci86Zml2ZWBcbiAqL1xuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XG4gICAgLy8gYFtcIm9uZVwiLCBcIlwiLCBcInRocmVlXCJdYCBjb3JyZXNwb25kcyB0byBvbWl0dGluZyBgOnR3b2AgZnJvbSBgL29uZS86dHdvPy90aHJlZWAgLT4gYC9vbmUvdGhyZWVgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZC5tYXAoc3VicGF0aCA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpKSk7XG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcChleHBsb2RlZCA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZCk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gIDogY29tcGFyZUluZGV4ZXMoYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpKSk7XG59XG5jb25zdCBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSBzID0+IHMgPT09IFwiKlwiO1xuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpLnJlZHVjZSgoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLCBpbml0aWFsU2NvcmUpO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgP1xuICAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV0gOlxuICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAwO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lKSB7XG4gIGxldCB7XG4gICAgcm91dGVzTWV0YVxuICB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aCh7XG4gICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVuZFxuICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gcCA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/PykkLyk7XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pXG4gIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAuZmlsdGVyKHNlZ21lbnQgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0ge1xuICAgICAgcGF0aDogcGF0dGVybixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgZW5kOiB0cnVlXG4gICAgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZSgobWVtbywgX3JlZiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1OYW1lLFxuICAgICAgaXNPcHRpb25hbFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8IFwiXCIsIHBhcmFtTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUsIGVuZCkge1xuICBpZiAoY2FzZVNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRydWU7XG4gIH1cbiAgd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgLnJlcGxhY2UoL1xcLzooW1xcdy1dKykoXFw/KT8vZywgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZSxcbiAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgfSk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZTogXCIqXCJcbiAgICB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIDtcbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhmYWxzZSwgXCJUaGUgVVJMIHBhdGggXFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIFwiICsgXCJtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgXCIgKyAoXCJlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLCBwYXJhbU5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcXFwiXCIgKyBwYXJhbU5hbWUgKyBcIlxcXCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlXCIgKyAoXCIgdGhlIHN0cmluZyBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseVwiKSArIChcIiBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIikgPyBiYXNlbmFtZS5sZW5ndGggLSAxIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0bywgZnJvbVBhdGhuYW1lKSB7XG4gIGlmIChmcm9tUGF0aG5hbWUgPT09IHZvaWQgMCkge1xuICAgIGZyb21QYXRobmFtZSA9IFwiL1wiO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gXCJDYW5ub3QgaW5jbHVkZSBhICdcIiArIGNoYXIgKyBcIicgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIFwiICsgKFwiYHRvLlwiICsgZmllbGQgKyBcImAgZmllbGQgW1wiICsgSlNPTi5zdHJpbmdpZnkocGF0aCkgKyBcIl0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcIikgKyAoXCJgdG8uXCIgKyBkZXN0ICsgXCJgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIFwiKSArIFwiYSBzdHJpbmcgaW4gPExpbmsgdG89XFxcIi4uLlxcXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5cIjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IGluZGV4ID09PSAwIHx8IG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKTtcbn1cbi8vIFJldHVybiB0aGUgYXJyYXkgb2YgcGF0aG5hbWVzIGZvciB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIC0gdXNlZCB0b1xuLy8gZ2VuZXJhdGUgdGhlIHJvdXRlUGF0aG5hbWVzIGlucHV0IGZvciByZXNvbHZlVG8oKVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgLy8gV2hlbiB2N19yZWxhdGl2ZVNwbGF0UGF0aCBpcyBlbmFibGVkLCB1c2UgdGhlIGZ1bGwgcGF0aG5hbWUgZm9yIHRoZSBsZWFmXG4gIC8vIG1hdGNoIHNvIHdlIGluY2x1ZGUgc3BsYXQgdmFsdWVzIGZvciBcIi5cIiBsaW5rcy4gIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzExMDUyI2lzc3VlY29tbWVudC0xODM2NTg5MzI5XG4gIGlmICh2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICAgIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAoKG1hdGNoLCBpZHgpID0+IGlkeCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxID8gbWF0Y2gucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2UpO1xuICB9XG4gIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUpIHtcbiAgaWYgKGlzUGF0aFJlbGF0aXZlID09PSB2b2lkIDApIHtcbiAgICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IF9leHRlbmRzKHt9LCB0b0FyZyk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKSk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bykpO1xuICAgIGludmFyaWFudCghdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcbiAgICAvLyBXaXRoIHJlbGF0aXZlPVwicm91dGVcIiAodGhlIGRlZmF1bHQpLCBlYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFuc1xuICAgIC8vIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZSBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleVxuICAgIC8vIGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGEgbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhXG4gICAgLy8gXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICBpZiAoIWlzUGF0aFJlbGF0aXZlICYmIHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPSB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPSAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bykge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lIDogdG8ucGF0aG5hbWU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IHNlYXJjaCA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSBoYXNoID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5jb25zdCBqc29uID0gZnVuY3Rpb24ganNvbihkYXRhLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0ge307XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xuICAgIHN0YXR1czogaW5pdFxuICB9IDogaW5pdDtcbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xuICAgIGhlYWRlcnNcbiAgfSkpO1xufTtcbmNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNsYXNzIERlZmVycmVkRGF0YSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlc3BvbnNlSW5pdCkge1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRlZmVycmVkS2V5cyA9IFtdO1xuICAgIGludmFyaWFudChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLCBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIik7XG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgX3JlZjIpID0+IHtcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cbiAgdHJhY2tQcm9taXNlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oZGF0YSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgdW5kZWZpbmVkLCBkYXRhKSwgZXJyb3IgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yKSk7XG4gICAgLy8gUmVnaXN0ZXIgcmVqZWN0aW9uIGxpc3RlbmVycyB0byBhdm9pZCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgb25cbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBvblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJiBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkL3JlamVjdGVkIHdpdGggdW5kZWZpbmVkLCB3ZSdsbCB0aHJvdyBhbiBlcnJvciBhcyB5b3VcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcbiAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB1bmRlZmluZWRFcnJvciA9IG5ldyBFcnJvcihcIkRlZmVycmVkIGRhdGEgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCBgdW5kZWZpbmVkYCwgXCIgKyBcInlvdSBtdXN0IHJlc29sdmUvcmVqZWN0IHdpdGggYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWRFcnJvclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodW5kZWZpbmVkRXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBlbWl0KGFib3J0ZWQsIHNldHRsZWRLZXkpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuICBzdWJzY3JpYmUoZm4pIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG4gIGFzeW5jIHJlc29sdmVEYXRhKHNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgdW53cmFwcGVkRGF0YSgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSwgXCJDYW4gb25seSB1bndyYXAgZGF0YSBvbiBpbml0aWFsaXplZCBhbmQgc2V0dGxlZCBkZWZlcnJlZHNcIik7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKChhY2MsIF9yZWYzKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2tleV06IHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKVxuICAgICAgfSk7XG4gICAgfSwge30pO1xuICB9XG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbHVlLl90cmFja2VkID09PSB0cnVlO1xufVxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpIHtcbiAgaWYgKCFpc1RyYWNrZWRQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cbmNvbnN0IGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZGF0YSwgaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IHt9O1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICBzdGF0dXM6IGluaXRcbiAgfSA6IGluaXQ7XG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdCh1cmwsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSAzMDI7XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiByZXNwb25zZUluaXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIF9leHRlbmRzKHt9LCByZXNwb25zZUluaXQsIHtcbiAgICBoZWFkZXJzXG4gIH0pKTtcbn07XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIGZvcmNlIGEgZG9jdW1lbnQgcmVsb2FkIHRvIHRoZSBuZXcgbG9jYXRpb24uXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3REb2N1bWVudCA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKlxuICogV2UgZG9uJ3QgZXhwb3J0IHRoZSBjbGFzcyBmb3IgcHVibGljIHVzZSBzaW5jZSBpdCdzIGFuIGltcGxlbWVudGF0aW9uXG4gKiBkZXRhaWwsIGJ1dCB3ZSBleHBvcnQgdGhlIGludGVyZmFjZSBhYm92ZSBzbyBmb2xrcyBjYW4gYnVpbGQgdGhlaXIgb3duXG4gKiBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxuICovXG5jbGFzcyBFcnJvclJlc3BvbnNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSwgaW50ZXJuYWwpIHtcbiAgICBpZiAoaW50ZXJuYWwgPT09IHZvaWQgMCkge1xuICAgICAgaW50ZXJuYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXCJwb3N0XCIsIFwicHV0XCIsIFwicGF0Y2hcIiwgXCJkZWxldGVcIl07XG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQodmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIpO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FyciA9IFtcImdldFwiLCAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzA3LCAzMDhdKTtcbmNvbnN0IElETEVfTkFWSUdBVElPTiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0JMT0NLRVIgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWRcbn07XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5jb25zdCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KVxufSk7XG5jb25zdCBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBDcmVhdGUgYSByb3V0ZXIgYW5kIGxpc3RlbiB0byBoaXN0b3J5IFBPUCBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdCkge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvdyA/IGluaXQud2luZG93IDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuICBpbnZhcmlhbnQoaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIik7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGlmIChpbml0Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gUm91dGVzIGtleWVkIGJ5IElEXG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICAvLyBSb3V0ZXMgaW4gdHJlZSBmb3JtYXQgZm9yIG1hdGNoaW5nXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X2ZldGNoZXJQZXJzaXN0OiBmYWxzZSxcbiAgICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBmYWxzZSxcbiAgICB2N19wYXJ0aWFsSHlkcmF0aW9uOiBmYWxzZSxcbiAgICB2N19wcmVwZW5kQmFzZW5hbWU6IGZhbHNlLFxuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZVxuICB9LCBpbml0LmZ1dHVyZSk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeSA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHJlc3RvcmF0aW9uIGtleXNcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSBgaHlkcmF0aW9uRGF0YWAgc2luY2Ugd2UgYXNzdW1lIHdlIHdlcmUgU1NSJ2QgYW5kIHRoYXRcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgZXJyb3IgYm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICB9KTtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJvdXRlXG4gICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7XG4gICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgIH07XG4gIH1cbiAgbGV0IGluaXRpYWxpemVkO1xuICBsZXQgaGFzTGF6eVJvdXRlcyA9IGluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxhenkpO1xuICBsZXQgaGFzTG9hZGVycyA9IGluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxvYWRlcik7XG4gIGlmIChoYXNMYXp5Um91dGVzKSB7XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoIWhhc0xvYWRlcnMpIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3Qgbm8gbG9hZGVycyB0byBydW4sIHRoZW4gd2UncmUgZ29vZCB0byBnb1xuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgIC8vIElmIHBhcnRpYWwgaHlkcmF0aW9uIGlzIGVuYWJsZWQsIHdlJ3JlIGluaXRpYWxpemVkIHNvIGxvbmcgYXMgd2Ugd2VyZVxuICAgIC8vIHByb3ZpZGVkIHdpdGggaHlkcmF0aW9uRGF0YSBmb3IgZXZlcnkgcm91dGUgd2l0aCBhIGxvYWRlciwgYW5kIG5vIGxvYWRlcnNcbiAgICAvLyB3ZXJlIG1hcmtlZCBmb3IgZXhwbGljaXQgaHlkcmF0aW9uXG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkobSA9PiBtLnJvdXRlLmxvYWRlciAmJiBtLnJvdXRlLmxvYWRlci5oeWRyYXRlICE9PSB0cnVlICYmIChsb2FkZXJEYXRhICYmIGxvYWRlckRhdGFbbS5yb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCB8fCBlcnJvcnMgJiYgZXJyb3JzW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWQpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaXRob3V0IHBhcnRpYWwgaHlkcmF0aW9uIC0gd2UncmUgaW5pdGlhbGl6ZWQgaWYgd2Ugd2VyZSBwcm92aWRlZCBhbnlcbiAgICAvLyBoeWRyYXRpb25EYXRhIC0gd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgY29tcGxldGVcbiAgICBpbml0aWFsaXplZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICB9XG4gIGxldCByb3V0ZXI7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsID8gZmFsc2UgOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICBsb2FkZXJEYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5hY3Rpb25EYXRhIHx8IG51bGwsXG4gICAgZXJyb3JzOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyB8fCBpbml0aWFsRXJyb3JzLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IG5ldyBNYXAoKVxuICB9O1xuICAvLyAtLSBTdGF0ZWZ1bCBpbnRlcm5hbCB2YXJpYWJsZXMgdG8gbWFuYWdlIG5hdmlnYXRpb25zIC0tXG4gIC8vIEN1cnJlbnQgbmF2aWdhdGlvbiBpbiBwcm9ncmVzcyAodG8gYmUgY29tbWl0dGVkIGluIGNvbXBsZXRlTmF2aWdhdGlvbilcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBwcmV2ZW50IHRoZSBzY3JvbGwgcmVzZXQgaWYgc2Nyb2xsIGNhbm5vdFxuICAvLyBiZSByZXN0b3JlZD9cbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gZW5hYmxlIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24/XG4gIGxldCBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gIC8vIFN0b3JlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBzbyB3ZSBjYW4gYXBwbHkgdGhlbSBvbiBQT1BcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIHBlcnNpc3RpbmcgYXBwbGllZCB0cmFuc2l0aW9ucyB0byBzZXNzaW9uU3RvcmFnZVxuICBsZXQgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxuICAvLyAgLSBzdWJtaXNzaW9ucyAoY29tcGxldGVkIG9yIGludGVycnVwdGVkKVxuICAvLyAgLSB1c2VSZXZhbGlkYXRvcigpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSByb3V0ZXMgdGhhdCByZXF1aXJlIHJldmFsaWRhdGlvbiBkdWVcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cbiAgbGV0IGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIC8vIEFib3J0Q29udHJvbGxlcnMgZm9yIGFueSBpbi1mbGlnaHQgZmV0Y2hlcnNcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIC8vIFRyYWNrIHRoZSBvdXRzdGFuZGluZyBwZW5kaW5nIG5hdmlnYXRpb24gZGF0YSBsb2FkIHRvIGJlIGNvbXBhcmVkIGFnYWluc3RcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcbiAgLy8gbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcCgpO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9uc1xuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IG5ldyBTZXQoKTtcbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXAoKTtcbiAgLy8gUmVmLWNvdW50IG1vdW50ZWQgZmV0Y2hlcnMgc28gd2Uga25vdyB3aGVuIGl0J3Mgb2sgdG8gY2xlYW4gdGhlbSB1cFxuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIEZldGNoZXJzIHRoYXQgaGF2ZSByZXF1ZXN0ZWQgYSBkZWxldGUgd2hlbiB1c2luZyB2N19mZXRjaGVyUGVyc2lzdCxcbiAgLy8gdGhleSdsbCBiZSBvZmZpY2lhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSByZXR1cm4gdG8gaWRsZVxuICBsZXQgZGVsZXRlZEZldGNoZXJzID0gbmV3IFNldCgpO1xuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGFsbCBzaWRlIGVmZmVjdHMgc2hvdWxkIGJlIGtpY2tlZCBvZmYgZnJvbSBoZXJlLlxuICAvLyBJbXBsZW1lbnRlZCBhcyBhIEZsdWVudCBBUEkgZm9yIGVhc2Ugb2Y6XG4gIC8vICAgbGV0IHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0KS5pbml0aWFsaXplKCk7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgLy8gSWYgaGlzdG9yeSBpbmZvcm1zIHVzIG9mIGEgUE9QIG5hdmlnYXRpb24sIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGJ1dCBkbyBub3QgdXBkYXRlXG4gICAgLy8gc3RhdGUuICBXZSdsbCB1cGRhdGUgb3VyIG93biBzdGF0ZSBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3Rpb246IGhpc3RvcnlBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBkZWx0YVxuICAgICAgfSA9IF9yZWY7XG4gICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgIGlmIChpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3YXJuaW5nKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLCBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIFwiICsgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICsgXCJ2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIFwiICsgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiKTtcbiAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmUtZG8gdGhlIHNhbWUgUE9QIG5hdmlnYXRpb24gd2UganVzdCBibG9ja2VkXG4gICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgICBibG9ja2Vyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgLy8gRklYTUU6IFRoaXMgZmVlbHMgZ3Jvc3MuICBIb3cgY2FuIHdlIGNsZWFudXAgdGhlIGxpbmVzIGJldHdlZW5cbiAgICAgIC8vIHNjcm9sbFJlc3RvcmF0aW9uL2FwcGxpZWRUcmFuc2l0aW9ucyBwZXJzaXN0YW5jZT9cbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICAvLyBOb3RlIHdlIGRvbid0IGRvIGFueSBoYW5kbGluZyBvZiBsYXp5IGhlcmUuICBGb3IgU1BBJ3MgaXQnbGwgZ2V0IGhhbmRsZWRcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcbiAgICAvLyByZXNvbHZlZCBwcmlvciB0byByb3V0ZXIgY3JlYXRpb24gc2luY2Ugd2UgY2FuJ3QgZ28gaW50byBhIGZhbGxiYWNrRWxlbWVudFxuICAgIC8vIFVJIGZvciBTU1InZCBhcHBzXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKEFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIGluaXRpYWxIeWRyYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG4gIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIG5vdGlmeSB0aGUgY2FsbGluZyBjb250ZXh0IG9mIHRoZSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgLy8gUHJlcCBmZXRjaGVyIGNsZWFudXAgc28gd2UgY2FuIHRlbGwgdGhlIFVJIHdoaWNoIGZldGNoZXIgZGF0YSBlbnRyaWVzXG4gICAgLy8gY2FuIGJlIHJlbW92ZWRcbiAgICBsZXQgY29tcGxldGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgZGVsZXRlZEZldGNoZXJzS2V5cyA9IFtdO1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50ZWQgZnJvbSB0aGUgVUkgYW5kIGNhbiBiZSB0b3RhbGx5IHJlbW92ZWRcbiAgICAgICAgICAgIGRlbGV0ZWRGZXRjaGVyc0tleXMucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5lZCB0byBpZGxlIGJ1dCBzdGlsbCBtb3VudGVkIGluIHRoZSBVSSwgc28gc2VtaS1yZW1haW5zIGZvclxuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9ucyBhbmQgc3VjaFxuICAgICAgICAgICAgY29tcGxldGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhIGxvY2FsIGNvcHkgc28gdGhhdCBpZiBmbHVzaFN5bmMgaXMgdXNlZCBhbmQgd2UgZW5kIHVwXG4gICAgLy8gcmVtb3ZpbmcgYW5kIGFkZGluZyBhIG5ldyBzdWJzY3JpYmVyIGR1ZSB0byB0aGUgdXNlQ2FsbGJhY2sgZGVwZW5kZW5jaWVzLFxuICAgIC8vIHdlIGRvbid0IGdldCBvdXJzZWx2ZXMgaW50byBhIGxvb3AgY2FsbGluZyB0aGUgbmV3IHN1YnNjcmliZXIgaW1tZWRpYXRlbHlcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHN0YXRlLCB7XG4gICAgICBkZWxldGVkRmV0Y2hlcnM6IGRlbGV0ZWRGZXRjaGVyc0tleXMsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBSZW1vdmUgaWRsZSBmZXRjaGVycyBmcm9tIHN0YXRlIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBpbi1mbGlnaHQgZmV0Y2hlcnMuXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgY29tcGxldGVkRmV0Y2hlcnMuZm9yRWFjaChrZXkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5mb3JFYWNoKGtleSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIH1cbiAgfVxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBuZXdTdGF0ZSwgX3RlbXApIHtcbiAgICB2YXIgX2xvY2F0aW9uJHN0YXRlLCBfbG9jYXRpb24kc3RhdGUyO1xuICAgIGxldCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgLy8gRGVkdWNlIGlmIHdlJ3JlIGluIGEgbG9hZGluZy9hY3Rpb25SZWxvYWQgc3RhdGU6XG4gICAgLy8gLSBXZSBoYXZlIGNvbW1pdHRlZCBhY3Rpb25EYXRhIGluIHRoZSBzdG9yZVxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gLSBXZSdyZSBwYXN0IHRoZSBzdWJtaXR0aW5nIHN0YXRlIGFuZCBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgLy8gLSBUaGUgbG9jYXRpb24gYmVpbmcgbG9hZGVkIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3RcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmICgoX2xvY2F0aW9uJHN0YXRlID0gbG9jYXRpb24uc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfbG9jYXRpb24kc3RhdGUuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGxldCBhY3Rpb25EYXRhO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgZGF0YSBpZiB3ZSdyZSB3cmFwcGluZyB1cCB0aGUgYWN0aW9uIHJlbG9hZFxuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFjdGlvbkRhdGEgb24gYW55IG90aGVyIGNvbXBsZXRlZCBuYXZpZ2F0aW9uc1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhID8gbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sIG5ld1N0YXRlLmVycm9ycykgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXG4gICAgLy8gc28gd2UgY2FuIHN0YXJ0IGZyZXNoXG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgcmVzcGVjdCB0aGUgdXNlciBmbGFnLiAgT3RoZXJ3aXNlIGRvbid0IHJlc2V0IG9uIG11dGF0aW9uXG4gICAgLy8gc3VibWlzc2lvbiBuYXZpZ2F0aW9ucyB1bmxlc3MgdGhleSByZWRpcmVjdFxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiAoKF9sb2NhdGlvbiRzdGF0ZTIgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZTIuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIDsgZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlBvcCkgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIC8vIE9uIFBPUCwgZW5hYmxlIHRyYW5zaXRpb25zIGlmIHRoZXkgd2VyZSBlbmFibGVkIG9uIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIEZvcndhcmQgdGFrZXMgcHJlY2VkZW5jZSBzbyB0aGV5IGJlaGF2ZSBsaWtlIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgZm9yd2FyZCBuYXYsIGFzc3VtZSB3ZSdyZSBwb3BwaW5nIGJhY2sgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhcHBsaWVkIHRyYW5zaXRpb24gb24gUFVTSC9SRVBMQUNFXG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2Vyc1xuICAgIH0pLCB7XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgdG8sIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mcm9tUm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCBmYWxzZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkgOyBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgYmxvY2tlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiXG4gICAgfSk7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvblxuICAgIH0pO1xuICB9XG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgcm91dGVcbiAgICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXNcbiAgICAgIH0sIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGxvY2F0aW9uLCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbik7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhO1xuICAgIGxldCBwZW5kaW5nRXJyb3I7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uLCBtYXRjaGVzLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdHMucmVwbGFjZSxcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgbG9hZGluZ05hdmlnYXRpb24sIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sIG9wdHMgJiYgb3B0cy5yZXBsYWNlLCBvcHRzICYmIG9wdHMuaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKTtcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgX2V4dGVuZHMoe1xuICAgICAgbWF0Y2hlc1xuICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICB9IDoge30sIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KSk7XG4gIH1cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIG1hdGNoZWQgYnkgdGhlIGxlYWYgcm91dGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBhbmQgaGFuZGxlXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBuYXZpZ2F0aW9uXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIHJlcXVlc3QsIGFjdGlvbk1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9IHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBTZW5kIGJhY2sgYW4gZW1wdHkgb2JqZWN0IHdlIGNhbiB1c2UgdG8gY2xlYXIgb3V0IGFueSBwcmlvciBhY3Rpb25EYXRhXG4gICAgICAgIHBlbmRpbmdBY3Rpb25EYXRhOiB7fSxcbiAgICAgICAgcGVuZGluZ0FjdGlvbkVycm9yOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZSwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKSB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIGFjdGl2ZVN1Ym1pc3Npb24sIGxvY2F0aW9uLCBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiAmJiBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGxcbiAgICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCB1cGRhdGVkRmV0Y2hlcnMgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgLy8gSWYgd2UgaGF2ZSBwYXJ0aWFsSHlkcmF0aW9uIGVuYWJsZWQsIHRoZW4gZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlXG4gICAgLy8gaW5pdGlhbCBkYXRhIGxvYWQgc2luY2UgaW90J3Mgbm90IGEgXCJuYXZpZ2F0aW9uXCJcbiAgICBpZiAoIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiAmJiAoIWZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uIHx8ICFpbml0aWFsSHlkcmF0aW9uKSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3Rpb25EYXRhID0gcGVuZGluZ0FjdGlvbkRhdGEgfHwgc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHtcbiAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb25cbiAgICAgIH0sIGFjdGlvbkRhdGEgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDAgPyB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGxcbiAgICAgIH0gOiB7XG4gICAgICAgIGFjdGlvbkRhdGFcbiAgICAgIH0gOiB7fSwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9IDoge30pLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHJmLmtleSkpIHtcbiAgICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXG4gICAgICAgIC8vICh2aWEgZGVsZXRlRmV0Y2hlcikgZG9lcyBub3QgYWJvcnQgdGhlIHRyaWdnZXJpbmcgbmF2aWdhdGlvbiB0aGF0XG4gICAgICAgIC8vIHRyaWdnZXJlZCB0aGUgcmV2YWxpZGF0aW9uXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gUHJveHkgbmF2aWdhdGlvbiBhYm9ydCB0aHJvdWdoIHRvIHJldmFsaWRhdGlvbiBmZXRjaGVyc1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKGYgPT4gYWJvcnRGZXRjaGVyKGYua2V5KSk7XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXF1ZXN0KTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQsIHtcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgbG9hZGVyUmVzdWx0cywgcGVuZGluZ0Vycm9yLCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0sIHNob3VsZFVwZGF0ZUZldGNoZXJzID8ge1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSA6IHt9KTtcbiAgfVxuICAvLyBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pdCBmb3IgdGhlIGdpdmVuIGZldGNoZXIga2V5XG4gIGZ1bmN0aW9uIGZldGNoKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicm91dGVyLmZldGNoKCkgd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICsgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgKyBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIik7XG4gICAgfVxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgaHJlZiwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCByb3V0ZUlkLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlbGF0aXZlKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoXG4gICAgICB9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgcGF0aCxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBlcnJvclxuICAgIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsIHRydWUsIG5vcm1hbGl6ZWRQYXRoLCBvcHRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0b3JlIG9mZiB0aGUgbWF0Y2ggc28gd2UgY2FuIGNhbGwgaXQncyBzaG91bGRSZXZhbGlkYXRlIG9uIHN1YnNlcXVlbnRcbiAgICAvLyByZXZhbGlkYXRpb25zXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKTtcbiAgfVxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIW1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgcm91dGVJZDogcm91dGVJZFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwsIHN1Ym1pc3Npb24pO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCBmZXRjaFJlcXVlc3QsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCk7XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXaGVuIHVzaW5nIHY3X2ZldGNoZXJQZXJzaXN0LCB3ZSBkb24ndCB3YW50IGVycm9ycyBidWJibGluZyB1cCB0byB0aGUgVUlcbiAgICAvLyBvciByZWRpcmVjdHMgcHJvY2Vzc2VkIGZvciB1bm1vdW50ZWQgZmV0Y2hlcnMgc28gd2UganVzdCByZXZlcnQgdGhlbSB0b1xuICAgIC8vIGlkbGVcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0ICYmIGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIExldCBTdWNjZXNzUmVzdWx0J3MgZmFsbCB0aHJvdWdoIGZvciByZXZhbGlkYXRpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGFjdGlvbiBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvbi4gIFdlIGFscmVhZHlcbiAgICAgICAgICAvLyBzZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCBzbyBhbGwgbG9hZGVycyBmb3IgdGhlIG5ldyByb3V0ZSBzaG91bGRcbiAgICAgICAgICAvLyBmaXJlIHVubGVzcyBvcHRlZCBvdXQgdmlhIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBuZXh0TG9jYXRpb24sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBuZXh0TG9jYXRpb24sIGZhbHNlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwge1xuICAgICAgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGFcbiAgICB9LCB1bmRlZmluZWQgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICApO1xuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKHJmID0+IHJmLmtleSAhPT0ga2V5KS5mb3JFYWNoKHJmID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcih1bmRlZmluZWQsIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgbGV0IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXZhbGlkYXRpb25SZXF1ZXN0KTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHIgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCB1bmRlZmluZWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBTaW5jZSB3ZSBsZXQgcmV2YWxpZGF0aW9ucyBjb21wbGV0ZSBldmVuIGlmIHRoZSBzdWJtaXR0aW5nIGZldGNoZXIgd2FzXG4gICAgLy8gZGVsZXRlZCwgb25seSBwdXQgaXQgYmFjayB0byBpZGxlIGlmIGl0IGhhc24ndCBiZWVuIGRlbGV0ZWRcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGEgbmF2aWdhdGlvbiBsb2FkaW5nIHN0YXRlIGFuZCB0aGlzIGZldGNoZXIgaXNcbiAgICAvLyBtb3JlIHJlY2VudCB0aGFuIHRoZSBuYXZpZ2F0aW9uLCB3ZSB3YW50IHRoZSBuZXdlciBkYXRhIHNvIGFib3J0IHRoZVxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB3aXRoIHRoZSBmZXRjaGVyIGRhdGEsIHByZXNlcnZpbmcgYW55IGV4aXN0aW5nXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cbiAgICAgIC8vIG1hbnVhbGx5IG1lcmdlIGhlcmUgc2luY2Ugd2UgYXJlbid0IGdvaW5nIHRocm91Z2ggY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIGxvYWRlckRhdGEsIG1hdGNoZXMsIGVycm9ycyksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcGF0aCwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGZldGNoUmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIG9yIHJlZGlyZWN0cyBmb2xsb3dlZCBmb3IgdW5tb3VudGVkXG4gICAgLy8gZmV0Y2hlcnMsIHNvIHNob3J0IGNpcmN1aXQgaGVyZSBpZiBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBVSVxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGxvYWRlciBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGhhbmRsZSByZWRpcmVjdHMgcmV0dXJuZWQgZnJvbSBhbiBhY3Rpb24gb3IgbG9hZGVyLlxuICAgKiBOb3JtYWxseSwgYSByZWRpcmVjdCBcInJlcGxhY2VzXCIgdGhlIG5hdmlnYXRpb24gdGhhdCB0cmlnZ2VyZWQgaXQuICBTbywgZm9yXG4gICAqIGV4YW1wbGU6XG4gICAqXG4gICAqICAtIHVzZXIgaXMgb24gL2FcbiAgICogIC0gdXNlciBjbGlja3MgYSBsaW5rIHRvIC9iXG4gICAqICAtIGxvYWRlciBmb3IgL2IgcmVkaXJlY3RzIHRvIC9jXG4gICAqXG4gICAqIEluIGEgbm9uLUpTIGFwcCB0aGUgYnJvd3NlciB3b3VsZCB0cmFjayB0aGUgaW4tZmxpZ2h0IG5hdmlnYXRpb24gdG8gL2IgYW5kXG4gICAqIHRoZW4gcmVwbGFjZSBpdCB3aXRoIC9jIHdoZW4gaXQgZW5jb3VudGVyZWQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlLiAgSW5cbiAgICogdGhlIGVuZCBpdCB3b3VsZCBvbmx5IGV2ZXIgdXBkYXRlIHRoZSBVUkwgYmFyIHdpdGggL2MuXG4gICAqXG4gICAqIEluIGNsaWVudC1zaWRlIHJvdXRpbmcgdXNpbmcgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgd2UgYWltIHRvIGVtdWxhdGVcbiAgICogdGhpcyBiZWhhdmlvciBhbmQgd2UgYWxzbyBkbyBub3QgdXBkYXRlIGhpc3RvcnkgdW50aWwgdGhlIGVuZCBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiAoaW5jbHVkaW5nIHByb2Nlc3NlZCByZWRpcmVjdHMpLiAgVGhpcyBtZWFucyB0aGF0IHdlIG5ldmVyXG4gICAqIGFjdHVhbGx5IHRvdWNoIGhpc3RvcnkgdW50aWwgd2UndmUgcHJvY2Vzc2VkIHJlZGlyZWN0cywgc28gd2UganVzdCB1c2VcbiAgICogdGhlIGhpc3RvcnkgYWN0aW9uIGZyb20gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb24gKFBVU0ggb3IgUkVQTEFDRSkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQocmVkaXJlY3RMb2NhdGlvbiwgXCJFeHBlY3RlZCBhIGxvY2F0aW9uIG9uIHRoZSByZWRpcmVjdCBuYXZpZ2F0aW9uXCIpO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QucmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGVcbiAgICB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3Quc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiBfZXh0ZW5kcyh7fSwgYWN0aXZlU3VibWlzc2lvbiwge1xuICAgICAgICAgIGZvcm1BY3Rpb246IHJlZGlyZWN0LmxvY2F0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShjdXJyZW50TWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi5tYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKSwgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4ge1xuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSwgZi5tYXRjaCwgZi5tYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnJvciA9IHtcbiAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9KV0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Jlc29sdmVEZWZlcnJlZFJlc3VsdHMoY3VycmVudE1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGxvYWRlclJlc3VsdHMsIGxvYWRlclJlc3VsdHMubWFwKCgpID0+IHJlcXVlc3Quc2lnbmFsKSwgZmFsc2UsIHN0YXRlLmxvYWRlckRhdGEpLCByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBmZXRjaGVyc1RvTG9hZC5tYXAoZiA9PiBmLm1hdGNoKSwgZmV0Y2hlclJlc3VsdHMsIGZldGNoZXJzVG9Mb2FkLm1hcChmID0+IGYuY29udHJvbGxlciA/IGYuY29udHJvbGxlci5zaWduYWwgOiBudWxsKSwgdHJ1ZSldKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0cyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0sIHtcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICAgIC8vIElmIHRoaXMgZmV0Y2hlciB3YXMgcHJldmlvdXNseSBtYXJrZWQgZm9yIGRlbGV0aW9uLCB1bm1hcmsgaXQgc2luY2Ugd2VcbiAgICAgIC8vIGhhdmUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXG4gICAgLy8gaW4gaXQncyBsb2FkaW5nIHBoYXNlIHNpbmNlIC0gd2UgZG9uJ3Qgd2FudCB0byBhYm9ydCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJldmFsaWRhdGlvbiBhbmQgd2FudCB0aGVtIHRvIGNvbXBsZXRlIGFuZCBsYW5kXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlKGtleSkge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIFwiRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogXCIgKyBrZXkpO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgXCJFeHBlY3RlZCBmZXRjaGVyOiBcIiArIGtleSk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5LCBuZXdCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLCBcIkludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiBcIiArIGJsb2NrZXIuc3RhdGUgKyBcIiAtPiBcIiArIG5ld0Jsb2NrZXIuc3RhdGUpO1xuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGJsb2NrZXJzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xuICAgICAgLy8gaXQgYW5kIGNhbiBsZXQgdGhpcyBuYXZpZ2F0aW9uIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhwcmVkaWNhdGUpIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHMgPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHBvc2l0aW9ucywgZ2V0UG9zaXRpb24sIGdldEtleSkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcy5tYXAobSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSkpO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhuZXdSb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiB0byA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246IHRvID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUsXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQocm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcbiAgICB2N190aHJvd0Fib3J0UmVhc29uOiBmYWxzZVxuICB9LCBvcHRzID8gb3B0cy5mdXR1cmUgOiBudWxsKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHJlcXVlc3QsIF90ZW1wMykge1xuICAgIGxldCB7XG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBXaGVuIHJldHVybmluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCwgd2UgcGF0Y2ggYmFjayBpbiB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIHNpbmNlIHdlIG5lZWQgaXQgZm9yIFJlYWN0IENvbnRleHQuICBCdXQgdGhpcyBoZWxwcyBrZWVwIG91ciBzdWJtaXQgYW5kXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGJhc2VuYW1lXG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHF1ZXJ5Um91dGUoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHRhcmdldGVkIHJvdXRlIHJlcXVlc3RzLCBlaXRoZXJcbiAgICogZm9yIGZldGNoID9fZGF0YSByZXF1ZXN0cyBvciByZXNvdXJjZSByb3V0ZSByZXF1ZXN0cy4gIEluIHRoaXMgY2FzZSwgd2VcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBkaXJlY3RseS4gIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBhIFJlc3BvbnNlIHJldHVybmVkXG4gICAqIGZyb20gdGhlIGFjdGlvbi9sb2FkZXIsIGJ1dCBpdCBtYXkgYmUgYSBwcmltaXRpdmUgb3Igb3RoZXIgdmFsdWUgYXMgd2VsbCAtXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBXZSBkbyByZXNwZWN0IHRoZSB0aHJvdy9yZXR1cm4gZGlmZmVyZW50aWF0aW9uLCBzbyBpZiBhbiBhY3Rpb24vbG9hZGVyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXG4gICAqIGNhbiBkbyBwcm9wZXIgYm91bmRhcnkgaWRlbnRpZmljYXRpb24gaW4gUmVtaXggd2hlcmUgYSB0aHJvd24gUmVzcG9uc2VcbiAgICogbXVzdCBnbyB0byB0aGUgQ2F0Y2ggQm91bmRhcnkgYnV0IGEgcmV0dXJuZWQgUmVzcG9uc2UgaXMgaGFwcHktcGF0aC5cbiAgICpcbiAgICogT25lIHRoaW5nIHRvIG5vdGUgaXMgdGhhdCBhbnkgUm91dGVyLWluaXRpYXRlZCBFcnJvcnMgdGhhdCBtYWtlIHNlbnNlXG4gICAqIHRvIGFzc29jaWF0ZSB3aXRoIGEgc3RhdHVzIGNvZGUgd2lsbCBiZSB0aHJvd24gYXMgYW4gRXJyb3JSZXNwb25zZVxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxuICAgKiBzZXJpYWxpemUgdGhlIGVycm9yIGFzIHRoZXkgc2VlIGZpdCB3aGlsZSBpbmNsdWRpbmcgdGhlIHByb3BlciByZXNwb25zZVxuICAgKiBjb2RlLiAgRXhhbXBsZXMgaGVyZSBhcmUgNDA0IGFuZCA0MDUgZXJyb3JzIHRoYXQgb2NjdXIgcHJpb3IgdG8gcmVhY2hpbmdcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCBfdGVtcDQpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSA9IF90ZW1wNCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDQ7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgbWF0Y2gpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgdmFyIF9yZXN1bHQkYWN0aXZlRGVmZXJyZTtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAoKF9yZXN1bHQkYWN0aXZlRGVmZXJyZSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHMpICE9IG51bGwgJiYgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKSB7XG4gICAgaW52YXJpYW50KHJlcXVlc3Quc2lnbmFsLCBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLCByZXF1ZXN0Q29udGV4dCwgcm91dGVNYXRjaCAhPSBudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBfZXh0ZW5kcyh7fSwgcmVzdWx0LCB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiwgd2UgdGhyb3dcbiAgICAgIC8vIGl0IHRvIGJhaWwgb3V0IGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyBoZXJlIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgIC8vIHJldHVybmVkIG9yIHRocmV3XG4gICAgICBpZiAoaXNRdWVyeVJvdXRlUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChyZXF1ZXN0LCBtYXRjaGVzLCBhY3Rpb25NYXRjaCwgcmVxdWVzdENvbnRleHQsIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJhY3Rpb25cIiwgcmVxdWVzdCwgYWN0aW9uTWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsIHtcbiAgICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuZGVmaW5lZCwge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczogX2V4dGVuZHMoe30sIHJlc3VsdC5oZWFkZXJzID8ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcmVzdWx0LnN0YXR1c0NvZGUgPyB7XG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxuICAgIH0gOiB7fSwge1xuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uRXJyb3IpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXSk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIobSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenkpO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW20ucm91dGUuaWRdOiBudWxsXG4gICAgICAgIH0pLCB7fSksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvbkVycm9yIHx8IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCB7XG4gICAgICBpc1N0YXRpY1JlcXVlc3Q6IHRydWUsXG4gICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSkpXSk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCwgZnV0dXJlKTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uRXJyb3IsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gQWRkIGEgbnVsbCBmb3IgYW55IG5vbi1sb2FkZXIgbWF0Y2hlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gbWF0Y2gucm91dGUuaWQpKTtcbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKCFleGVjdXRlZExvYWRlcnMuaGFzKG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgICBjb250ZXh0LmxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcy5zaXplID4gMCA/IE9iamVjdC5mcm9tRW50cmllcyhhY3RpdmVEZWZlcnJlZHMuZW50cmllcygpKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZVxuICB9O1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihyb3V0ZXMsIGNvbnRleHQsIGVycm9yKSB7XG4gIGxldCBuZXdDb250ZXh0ID0gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvclxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpIHtcbiAgaWYgKGZ1dHVyZS52N190aHJvd0Fib3J0UmVhc29uICYmIHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCIoKSBjYWxsIGFib3J0ZWQ6IFwiICsgcmVxdWVzdC5tZXRob2QgKyBcIiBcIiArIHJlcXVlc3QudXJsKTtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHByZXBlbmRCYXNlbmFtZSwgdG8sIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCksIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XG4gIC8vIGxvY2F0aW9uLCB1bmxpa2Ugd2hlbiB0bz1cIi5cIiBhbmQgd2UganVzdCBpbmhlcml0IHRoZSBwYXRoLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2ggJiYgYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKSkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lLiAgSWZcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaFxuICAvLyBvbiByb290IGFjdGlvbnNcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhub3JtYWxpemVGb3JtTWV0aG9kLCBpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgdHlwZTogXCJpbnZhbGlkLWJvZHlcIlxuICAgIH0pXG4gIH0pO1xuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kID8gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIDogcmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgP1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKChhY2MsIF9yZWYzKSA9PiB7XG4gICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBcIlwiICsgYWNjICsgbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIlxcblwiO1xuICAgICAgfSwgXCJcIikgOiBTdHJpbmcob3B0cy5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIC8vIGpzb24gb25seSBzdXBwb3J0cyBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQodHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICBsZXQgc2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gIH1cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksXG4gICAgc3VibWlzc2lvblxuICB9O1xufVxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCkge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpc0luaXRpYWxMb2FkLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcikge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdIDogcGVuZGluZ0FjdGlvbkRhdGEgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAvLyBQaWNrIG5hdmlnYXRpb24gbWF0Y2hlcyB0aGF0IGFyZSBuZXQtbmV3IG9yIHF1YWxpZnkgZm9yIHJldmFsaWRhdGlvblxuICBsZXQgYm91bmRhcnlJZCA9IHBlbmRpbmdFcnJvciA/IE9iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF0gOiB1bmRlZmluZWQ7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBib3VuZGFyeUlkKTtcbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlXG4gICAgfSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgaWYgKHJvdXRlLmxvYWRlci5oeWRyYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGUuaWRdID09PSB1bmRlZmluZWQgJiYgKFxuICAgICAgLy8gRG9uJ3QgcmUtcnVuIGlmIHRoZSBsb2FkZXIgcmFuIGFuZCB0aHJldyBhbiBlcnJvclxuICAgICAgIXN0YXRlLmVycm9ycyB8fCBzdGF0ZS5lcnJvcnNbcm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgbG9hZGVyIG9uIG5ldyByb3V0ZSBpbnN0YW5jZXMgYW5kIHBlbmRpbmcgZGVmZXIgY2FuY2VsbGF0aW9uc1xuICAgIGlmIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8IGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnNvbWUoaWQgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCBfZXh0ZW5kcyh7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG5leHRSb3V0ZU1hdGNoLnBhcmFtc1xuICAgIH0sIHN1Ym1pc3Npb24sIHtcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09IG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgIH0pKTtcbiAgfSk7XG4gIC8vIFBpY2sgZmV0Y2hlci5sb2FkcyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZTpcbiAgICAvLyAgLSBvbiBpbml0aWFsIGxvYWQgKHNob3VsZG4ndCBiZSBhbnkgZmV0Y2hlcnMgdGhlbiBhbnl3YXkpXG4gICAgLy8gIC0gaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIC8vICAgIC0gbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIFVSTCAodjdfZmV0Y2hlclBlcnNpc3Q9ZmFsc2UpXG4gICAgLy8gICAgLSB3YXMgdW5tb3VudGVkIGJ1dCBwZXJzaXN0ZWQgZHVlIHRvIHY3X2ZldGNoZXJQZXJzaXN0PXRydWVcbiAgICBpZiAoaXNJbml0aWFsTG9hZCB8fCAhbWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuICAgIC8vIElmIHRoZSBmZXRjaGVyIHBhdGggbm8gbG9uZ2VyIG1hdGNoZXMsIHB1c2ggaXQgaW4gd2l0aCBudWxsIG1hdGNoZXMgc29cbiAgICAvLyB3ZSBjYW4gdHJpZ2dlciBhIDQwNCBpbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEuICBOb3RlIHRoaXMgaXNcbiAgICAvLyBjdXJyZW50bHkgb25seSBhIHVzZS1jYXNlIGZvciBSZW1peCBITVIgd2hlcmUgdGhlIHJvdXRlIHRyZWUgY2FuIGNoYW5nZVxuICAgIC8vIGF0IHJ1bnRpbWUgYW5kIHJlbW92ZSBhIHJvdXRlIHByZXZpb3VzbHkgbG9hZGVkIHZpYSBhIGZldGNoZXJcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXZhbGlkYXRpbmcgZmV0Y2hlcnMgYXJlIGRlY291cGxlZCBmcm9tIHRoZSByb3V0ZSBtYXRjaGVzIHNpbmNlIHRoZXlcbiAgICAvLyBsb2FkIGZyb20gYSBzdGF0aWMgaHJlZi4gIFRoZXkgcmV2YWxpZGF0ZSBiYXNlZCBvbiBleHBsaWNpdCByZXZhbGlkYXRpb25cbiAgICAvLyAoc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZSlcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiYgZmV0Y2hlci5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBmZXRjaGVyIGhhc24ndCBldmVyIGNvbXBsZXRlZCBsb2FkaW5nIHlldCwgdGhlbiB0aGlzIGlzbid0IGFcbiAgICAgIC8vIHJldmFsaWRhdGlvbiwgaXQgd291bGQganVzdCBiZSBhIGJyYW5kIG5ldyBsb2FkIGlmIGFuIGV4cGxpY2l0XG4gICAgICAvLyByZXZhbGlkYXRpb24gaXMgcmVxdWlyZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBpc1JldmFsaWRhdGlvblJlcXVpcmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFueSB1c2VyLWRlZmluZWQgc2hvdWxkUmV2YWxpZGF0ZSwgZGVmYXVsdGluZ1xuICAgICAgLy8gdG8gZXhwbGljaXQgcmV2YWxpZGF0aW9ucyBvbmx5XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIF9leHRlbmRzKHtcbiAgICAgICAgY3VycmVudFVybCxcbiAgICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtc1xuICAgICAgfSwgc3VibWlzc2lvbiwge1xuICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBpc1JldmFsaWRhdGlvblJlcXVpcmVkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoY3VycmVudExvYWRlckRhdGEsIGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGlzTmV3ID1cbiAgLy8gW2FdIC0+IFthLCBiXVxuICAhY3VycmVudE1hdGNoIHx8XG4gIC8vIFthLCBiXSAtPiBbYSwgY11cbiAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcbiAgLy8gQWx3YXlzIGxvYWQgaWYgdGhpcyBpcyBhIG5ldC1uZXcgcm91dGUgb3Igd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YVxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG4vKipcbiAqIEV4ZWN1dGUgcm91dGUubGF6eSgpIG1ldGhvZHMgdG8gbGF6aWx5IGxvYWQgcm91dGUgbW9kdWxlcyAobG9hZGVyLCBhY3Rpb24sXG4gKiBzaG91bGRSZXZhbGlkYXRlKSBhbmQgdXBkYXRlIHRoZSByb3V0ZU1hbmlmZXN0IGluIHBsYWNlIHdoaWNoIHNoYXJlcyBvYmplY3RzXG4gKiB3aXRoIGRhdGFSb3V0ZXMgc28gdGhvc2UgZ2V0IHVwZGF0ZWQgYXMgd2VsbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShyb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCkge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcbiAgLy8gSWYgdGhlIGxhenkgcm91dGUgZnVuY3Rpb24gd2FzIGV4ZWN1dGVkIGFuZCByZW1vdmVkIGJ5IGFub3RoZXIgcGFyYWxsZWxcbiAgLy8gY2FsbCB0aGVuIHdlIGNhbiByZXR1cm4gLSBmaXJzdCBsYXp5KCkgdG8gZmluaXNoIHdpbnMgYmVjYXVzZSB0aGUgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIGxhenkgaXMgZXhwZWN0ZWQgdG8gYmUgc3RhdGljXG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgLy8gb24gdGhlIHJvdXRlIHVwZGF0ZXNcbiAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgd2FybmluZyghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkLCBcIlJvdXRlIFxcXCJcIiArIHJvdXRlVG9VcGRhdGUuaWQgKyBcIlxcXCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIFwiICsgXCJkZWZpbmVkIGJ1dCBpdHMgbGF6eSBmdW5jdGlvbiBpcyBhbHNvIHJldHVybmluZyBhIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5LiBcIiArIChcIlRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIHdpbGwgYmUgaWdub3JlZC5cIikpO1xuICAgIGlmICghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkICYmICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5KSkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIG1hcFJvdXRlUHJvcGVydGllc1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBfZXh0ZW5kcyh7fSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlVG9VcGRhdGUpLCB7XG4gICAgbGF6eTogdW5kZWZpbmVkXG4gIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDtcbiAgbGV0IHJ1bkhhbmRsZXIgPSBoYW5kbGVyID0+IHtcbiAgICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlcih7XG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICBjb250ZXh0OiBvcHRzLnJlcXVlc3RDb250ZXh0XG4gICAgfSksIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIFJ1biBzdGF0aWNhbGx5IGRlZmluZWQgaGFuZGxlciBpbiBwYXJhbGxlbCB3aXRoIGxhenkoKVxuICAgICAgICBsZXQgaGFuZGxlckVycm9yO1xuICAgICAgICBsZXQgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciB0aHJvd3MsIGRvbid0IGxldCBpdCBpbW1lZGlhdGVseSBidWJibGUgb3V0LFxuICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgcnVuSGFuZGxlcihoYW5kbGVyKS5jYXRjaChlID0+IHtcbiAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICB9KSwgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCldKTtcbiAgICAgICAgaWYgKGhhbmRsZXJFcnJvcikge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb2FkIGxhenkgcm91dGUgbW9kdWxlLCB0aGVuIHJ1biBhbnkgcmV0dXJuZWQgaGFuZGxlclxuICAgICAgICBhd2FpdCBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KTtcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVuIGV2ZW4gaWYgd2UgZ290IGludGVycnVwdGVkIHRvIG1haW50YWluIGNvbnNpc3RlbmN5XG4gICAgICAgICAgLy8gd2l0aCB1bi1hYm9ydGFibGUgYmVoYXZpb3Igb2YgaGFuZGxlciBleGVjdXRpb24gb24gbm9uLWxhenkgb3JcbiAgICAgICAgICAvLyBwcmV2aW91c2x5LWxhenktbG9hZGVkIHJvdXRlc1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhenkoKSByb3V0ZSBoYXMgbm8gbG9hZGVyIHRvIHJ1bi4gIFNob3J0IGNpcmN1aXQgaGVyZSBzbyB3ZSBkb24ndFxuICAgICAgICAgIC8vIGhpdCB0aGUgaW52YXJpYW50IGJlbG93IHRoYXQgZXJyb3JzIG9uIHJldHVybmluZyB1bmRlZmluZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQocmVzdWx0ICE9PSB1bmRlZmluZWQsIFwiWW91IGRlZmluZWQgXCIgKyAodHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwiYW4gYWN0aW9uXCIgOiBcImEgbG9hZGVyXCIpICsgXCIgZm9yIHJvdXRlIFwiICsgKFwiXFxcIlwiICsgbWF0Y2gucm91dGUuaWQgKyBcIlxcXCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIGBcIiArIHR5cGUgKyBcImAgXCIpICsgXCJmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIGBudWxsYC5cIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgIC8vIFByb2Nlc3MgcmVkaXJlY3RzXG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1cykpIHtcbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgICAgaW52YXJpYW50KGxvY2F0aW9uLCBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCIpO1xuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbG9jYXRpb24gPSBub3JtYWxpemVUbyhuZXcgVVJMKHJlcXVlc3QudXJsKSwgbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmluZGV4T2YobWF0Y2gpICsgMSksIGJhc2VuYW1lLCB0cnVlLCBsb2NhdGlvbiwgdjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbikgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQ6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpICE9PSBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAob3B0cy5pc1JvdXRlUmVxdWVzdCkge1xuICAgICAgbGV0IHF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHRcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgfTtcbiAgfVxuICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgZXJyb3I6IHJlc3VsdFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGVmZXJyZWREYXRhKHJlc3VsdCkpIHtcbiAgICB2YXIgX3Jlc3VsdCRpbml0LCBfcmVzdWx0JGluaXQyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiAoX3Jlc3VsdCRpbml0ID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogKChfcmVzdWx0JGluaXQyID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQyLmhlYWRlcnMpICYmIG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHRcbiAgfTtcbn1cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChoaXN0b3J5LCBsb2NhdGlvbiwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0ID0ge1xuICAgIHNpZ25hbFxuICB9O1xuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1FbmNUeXBlXG4gICAgfSA9IHN1Ym1pc3Npb247XG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXG4gICAgLy8gd29uJ3QgYmUgcHJvcGVybHkgbm9ybWFsaXplZCB0byB1cHBlcmNhc2UgYW5kIHJlc3VsdHMgaW4gYSA0MDUgZXJyb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2RcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlXG4gICAgICB9KTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHN1Ym1pc3Npb24uanNvbik7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLmZvcm1EYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2YWx1ZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgYWN0aXZlRGVmZXJyZWRzKSB7XG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIC8vIFByb2Nlc3MgbG9hZGVyIHJlc3VsdHMgaW50byBzdGF0ZS5sb2FkZXJEYXRhL3N0YXRlLmVycm9yc1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICBsZXQgaWQgPSBtYXRjaGVzVG9Mb2FkW2luZGV4XS5yb3V0ZS5pZDtcbiAgICBpbnZhcmlhbnQoIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSwgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIik7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gTG9vayB1cHdhcmRzIGZyb20gdGhlIG1hdGNoZWQgcm91dGUgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgICAgICBlcnJvciA9IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXTtcbiAgICAgICAgcGVuZGluZ0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuICAgICAgLy8gUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXMgaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICB9XG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIElmIHdlIGRpZG4ndCBjb25zdW1lIHRoZSBwZW5kaW5nIGFjdGlvbiBlcnJvciAoaS5lLiwgYWxsIGxvYWRlcnNcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcbiAgLy8gdGhyb3dpbmcgcm91dGVcbiAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgIGVycm9ycyA9IHBlbmRpbmdFcnJvcjtcbiAgICBsb2FkZXJEYXRhW09iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpIHtcbiAgbGV0IHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9yc1xuICB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIGFjdGl2ZURlZmVycmVkcyk7XG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbnRyb2xsZXJcbiAgICB9ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbaW5kZXhdO1xuICAgIGludmFyaWFudChmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLCBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCIpO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1tpbmRleF07XG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciBhYm9ydGVkIGZldGNoZXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSBfZXh0ZW5kcyh7fSwgZXJyb3JzLCB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBfZXh0ZW5kcyh7fSwgbmV3TG9hZGVyRGF0YSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAobmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmIChuZXdMb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbmV3TG9hZGVyRGF0YVtpZF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBEb24ndCBrZWVwIGFueSBsb2FkZXIgZGF0YSBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKSA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZChtID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZChyID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IFwiX19zaGltLWVycm9yLXJvdXRlX19cIlxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFt7XG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICByb3V0ZVxuICAgIH1dLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywgX3RlbXA1KSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZVxuICB9ID0gX3RlbXA1ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNTtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZCArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGEgYGxvYWRlcmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIlJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIk5vIHJvdXRlIG1hdGNoZXMgVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCIgcmVxdWVzdCB0byBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIiBidXQgXCIgKyAoXCJkaWQgbm90IHByb3ZpZGUgYW4gYGFjdGlvbmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFxcXCJcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCJcXFwiXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzIHx8IDUwMCwgc3RhdHVzVGV4dCwgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksIHRydWUpO1xufVxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZHg6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aChfZXh0ZW5kcyh7fSwgcGFyc2VkUGF0aCwge1xuICAgIGhhc2g6IFwiXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XG4gIGlmIChhLnBhdGhuYW1lICE9PSBiLnBhdGhuYW1lIHx8IGEuc2VhcmNoICE9PSBiLnNlYXJjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgdGhlIGhhc2ggaXMgcmVtb3ZlZCB0aGUgYnJvd3NlciB3aWxsIHJlLXBlcmZvcm0gYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZSkge1xuICBsZXQgZGVmZXJyZWQgPSB2YWx1ZTtcbiAgcmV0dXJuIGRlZmVycmVkICYmIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJiAob2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZGF0YSB8fCBvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBzaWduYWxzLCBpc0ZldGNoZXIsIGN1cnJlbnRMb2FkZXJEYXRhKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID0gY3VycmVudE1hdGNoICE9IG51bGwgJiYgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJiAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHNpZ25hbCwgXCJFeHBlY3RlZCBhbiBBYm9ydFNpZ25hbCBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXIgZGVmZXJyZWQgcmVzdWx0XCIpO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCB1bndyYXApIHtcbiAgaWYgKHVud3JhcCA9PT0gdm9pZCAwKSB7XG4gICAgdW53cmFwID0gZmFsc2U7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKHYgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xuICBsZXQge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZSxcbiAgICB0ZXh0LFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb25cbiAgfSA9IG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YSkge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgdHJhbnNpdGlvbnMpIHtcbiAgICAgIGpzb25ba10gPSBbLi4udl07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBfd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UgKFwiICsgZXJyb3IgKyBcIikuXCIpO1xuICAgIH1cbiAgfVxufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24sIElETEVfQkxPQ0tFUiwgSURMRV9GRVRDSEVSLCBJRExFX05BVklHQVRJT04sIFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wsIERlZmVycmVkRGF0YSBhcyBVTlNBRkVfRGVmZXJyZWREYXRhLCBFcnJvclJlc3BvbnNlSW1wbCBhcyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIGFzIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyBhcyBVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcywgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyBhcyBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcywgaW52YXJpYW50IGFzIFVOU0FGRV9pbnZhcmlhbnQsIHdhcm5pbmcgYXMgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUGF0aCwgY3JlYXRlUm91dGVyLCBjcmVhdGVTdGF0aWNIYW5kbGVyLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yLCBnZXRUb1BhdGhuYW1lLCBpc0RlZmVycmVkRGF0YSwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpvaW5QYXRocywganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgbm9ybWFsaXplUGF0aG5hbWUsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlc29sdmVQYXRoLCByZXNvbHZlVG8sIHN0cmlwQmFzZW5hbWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfcmVmIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwibmFtZSIsIm9yaWdpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVzdWx0VHlwZSIsImltbXV0YWJsZVJvdXRlS2V5cyIsIlNldCIsImlzSW5kZXhSb3V0ZSIsInJvdXRlIiwiY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsInJvdXRlcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsInBhcmVudFBhdGgiLCJtYW5pZmVzdCIsInRyZWVQYXRoIiwiaWQiLCJqb2luIiwiY2hpbGRyZW4iLCJpbmRleFJvdXRlIiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiZGF0YSIsImhhbmRsZSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsImNvbmNhdCIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiZm9yRWFjaCIsIl9yb3V0ZSRwYXRoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsIm1hdGNoUGF0aCIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwiZ2VuZXJhdGVQYXRoIiwib3JpZ2luYWxQYXRoIiwicHJlZml4IiwicCIsIlN0cmluZyIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsImNvbXBpbGVkUGFyYW1zIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbyIsInBhcmFtTmFtZSIsInNwbGF0VmFsdWUiLCJzYWZlbHlEZWNvZGVVUklDb21wb25lbnQiLCJyZWdleHBTb3VyY2UiLCJfIiwiUmVnRXhwIiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJyZXNvbHZlUGF0aCIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJnZXRSZXNvbHZlVG9NYXRjaGVzIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJwYXRoTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwiY29uc3RydWN0b3IiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJfcmVmMiIsInRyYWNrUHJvbWlzZSIsImRvbmUiLCJhZGQiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMyIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1c1RleHQiLCJpbnRlcm5hbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsInRleHQiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSIsImNyZWF0ZVJvdXRlciIsInJvdXRlcldpbmRvdyIsImlzQnJvd3NlciIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlciIsImRldGVjdEVycm9yQm91bmRhcnkiLCJkYXRhUm91dGVzIiwiaW5GbGlnaHREYXRhUm91dGVzIiwiZnV0dXJlIiwidjdfZmV0Y2hlclBlcnNpc3QiLCJ2N19ub3JtYWxpemVGb3JtTWV0aG9kIiwidjdfcGFydGlhbEh5ZHJhdGlvbiIsInY3X3ByZXBlbmRCYXNlbmFtZSIsInVubGlzdGVuSGlzdG9yeSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsTWF0Y2hlcyIsImluaXRpYWxFcnJvcnMiLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImluaXRpYWxpemVkIiwiaGFzTGF6eVJvdXRlcyIsIm0iLCJsYXp5IiwiaGFzTG9hZGVycyIsImxvYWRlciIsImVycm9ycyIsImh5ZHJhdGUiLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImFjdGlvbkRhdGEiLCJmZXRjaGVycyIsIk1hcCIsImJsb2NrZXJzIiwicGVuZGluZ0FjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIiwiYXBwbGllZFZpZXdUcmFuc2l0aW9ucyIsInJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVGZXRjaGVycyIsImRlbGV0ZWRGZXRjaGVycyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwicmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyIsIl9zYXZlQXBwbGllZFRyYW5zaXRpb25zIiwicGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyIsImluaXRpYWxIeWRyYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJkZWxldGVGZXRjaGVyIiwiZGVsZXRlQmxvY2tlciIsIm5ld1N0YXRlIiwib3B0cyIsImNvbXBsZXRlZEZldGNoZXJzIiwiZGVsZXRlZEZldGNoZXJzS2V5cyIsImZldGNoZXIiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHMiLCJ2aWV3VHJhbnNpdGlvbk9wdHMiLCJ1bnN0YWJsZV9mbHVzaFN5bmMiLCJmbHVzaFN5bmMiLCJjb21wbGV0ZU5hdmlnYXRpb24iLCJfdGVtcCIsIl9sb2NhdGlvbiRzdGF0ZSIsIl9sb2NhdGlvbiRzdGF0ZTIiLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJwcmlvclBhdGhzIiwidG9QYXRocyIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwiZW5hYmxlVmlld1RyYW5zaXRpb24iLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiIsInJldmFsaWRhdGUiLCJpbnRlcnJ1cHRBY3RpdmVMb2FkcyIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJub3RGb3VuZE1hdGNoZXMiLCJjYW5jZWxBY3RpdmVEZWZlcnJlZHMiLCJpc0hhc2hDaGFuZ2VPbmx5IiwicmVxdWVzdCIsImNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0IiwicGVuZGluZ0FjdGlvbkRhdGEiLCJmaW5kTmVhcmVzdEJvdW5kYXJ5IiwiYWN0aW9uT3V0cHV0IiwiaGFuZGxlQWN0aW9uIiwic2hvcnRDaXJjdWl0ZWQiLCJwZW5kaW5nQWN0aW9uRXJyb3IiLCJnZXRMb2FkaW5nTmF2aWdhdGlvbiIsIlJlcXVlc3QiLCJoYW5kbGVMb2FkZXJzIiwiZmV0Y2hlclN1Ym1pc3Npb24iLCJnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbiIsImFjdGlvbk1hdGNoIiwiZ2V0VGFyZ2V0TWF0Y2giLCJ0eXBlIiwibWV0aG9kIiwicm91dGVJZCIsImNhbGxMb2FkZXJPckFjdGlvbiIsImlzUmVkaXJlY3RSZXN1bHQiLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImlzRXJyb3JSZXN1bHQiLCJib3VuZGFyeU1hdGNoIiwiaXNEZWZlcnJlZFJlc3VsdCIsImFjdGl2ZVN1Ym1pc3Npb24iLCJnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24iLCJtYXRjaGVzVG9Mb2FkIiwicmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJnZXRNYXRjaGVzVG9Mb2FkIiwidXBkYXRlZEZldGNoZXJzIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsInJmIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsImdldExvYWRpbmdGZXRjaGVyIiwiYWJvcnRGZXRjaGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsInJlc3VsdHMiLCJsb2FkZXJSZXN1bHRzIiwiZmV0Y2hlclJlc3VsdHMiLCJjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEiLCJmaW5kUmVkaXJlY3QiLCJmZXRjaGVyS2V5IiwicHJvY2Vzc0xvYWRlckRhdGEiLCJkZWZlcnJlZERhdGEiLCJkaWRBYm9ydEZldGNoTG9hZHMiLCJhYm9ydFN0YWxlRmV0Y2hMb2FkcyIsInNob3VsZFVwZGF0ZUZldGNoZXJzIiwiZmV0Y2giLCJzZXRGZXRjaGVyRXJyb3IiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsInJlcXVlc3RNYXRjaGVzIiwiZXhpc3RpbmdGZXRjaGVyIiwidXBkYXRlRmV0Y2hlclN0YXRlIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJvcmlnaW5hdGluZ0xvYWRJZCIsImFjdGlvblJlc3VsdCIsImdldERvbmVGZXRjaGVyIiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcDIiLCJyZWRpcmVjdExvY2F0aW9uIiwiaXNEb2N1bWVudFJlbG9hZCIsInJlbG9hZERvY3VtZW50IiwicmVkaXJlY3RIaXN0b3J5QWN0aW9uIiwiY3VycmVudE1hdGNoZXMiLCJmZXRjaGVyc1RvTG9hZCIsImFsbCIsInJlc29sdmVEZWZlcnJlZFJlc3VsdHMiLCJnZXRGZXRjaGVyIiwiZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlIiwiY291bnQiLCJtYXJrRmV0Y2hlcnNEb25lIiwiZG9uZUtleXMiLCJsYW5kZWRJZCIsInllZXRlZEtleXMiLCJnZXRCbG9ja2VyIiwiYmxvY2tlciIsIm5ld0Jsb2NrZXIiLCJibG9ja2VyRnVuY3Rpb24iLCJwcmVkaWNhdGUiLCJjYW5jZWxsZWRSb3V0ZUlkcyIsImRmZCIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJnZXRLZXkiLCJ5IiwiZ2V0U2Nyb2xsS2V5IiwiX2ludGVybmFsU2V0Um91dGVzIiwibmV3Um91dGVzIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsIl9pbnRlcm5hbEFjdGl2ZURlZmVycmVkcyIsIlVOU0FGRV9ERUZFUlJFRF9TWU1CT0wiLCJTeW1ib2wiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwidjdfdGhyb3dBYm9ydFJlYXNvbiIsInF1ZXJ5IiwiX3RlbXAzIiwicmVxdWVzdENvbnRleHQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0dXNDb2RlIiwibG9hZGVySGVhZGVycyIsImFjdGlvbkhlYWRlcnMiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicXVlcnlSb3V0ZSIsIl90ZW1wNCIsImZpbmQiLCJ2YWx1ZXMiLCJfcmVzdWx0JGFjdGl2ZURlZmVycmUiLCJyb3V0ZU1hdGNoIiwic3VibWl0IiwibG9hZFJvdXRlRGF0YSIsImlzUXVlcnlSb3V0ZVJlc3BvbnNlIiwiaXNSZWRpcmVjdFJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJpc1N0YXRpY1JlcXVlc3QiLCJ0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IiLCJMb2NhdGlvbiIsImNvbnRleHQiLCJsb2FkZXJSZXF1ZXN0IiwiZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkiLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZXhlY3V0ZWRMb2FkZXJzIiwiZnJvbUVudHJpZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwicmVhc29uIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImJvZHkiLCJwcmVwZW5kQmFzZW5hbWUiLCJjb250ZXh0dWFsTWF0Y2hlcyIsImFjdGl2ZVJvdXRlTWF0Y2giLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJub3JtYWxpemVGb3JtTWV0aG9kIiwiaXNGZXRjaGVyIiwiZ2V0SW52YWxpZEJvZHlFcnJvciIsInJhd0Zvcm1NZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInN0cmlwSGFzaEZyb21QYXRoIiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiZmluZEluZGV4IiwiaXNJbml0aWFsTG9hZCIsImN1cnJlbnRVcmwiLCJuZXh0VXJsIiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsImN1cnJlbnRSb3V0ZU1hdGNoIiwibmV4dFJvdXRlTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSIsImlzTmV3Um91dGVJbnN0YW5jZSIsImZldGNoZXJNYXRjaGVzIiwiZmV0Y2hlck1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZSIsImN1cnJlbnRMb2FkZXJEYXRhIiwiY3VycmVudE1hdGNoIiwiaXNOZXciLCJpc01pc3NpbmdEYXRhIiwiY3VycmVudFBhdGgiLCJsb2FkZXJNYXRjaCIsImFyZyIsInJvdXRlQ2hvaWNlIiwibG9hZExhenlSb3V0ZU1vZHVsZSIsImxhenlSb3V0ZSIsInJvdXRlVG9VcGRhdGUiLCJyb3V0ZVVwZGF0ZXMiLCJsYXp5Um91dGVQcm9wZXJ0eSIsInN0YXRpY1JvdXRlVmFsdWUiLCJpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJydW5IYW5kbGVyIiwiaGFuZGxlciIsImhhbmRsZXJFcnJvciIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJxdWVyeVJvdXRlUmVzcG9uc2UiLCJjb250ZW50VHlwZSIsImlzRGVmZXJyZWREYXRhIiwiX3Jlc3VsdCRpbml0IiwiX3Jlc3VsdCRpbml0MiIsImRlZmVycmVkIiwiZm91bmRFcnJvciIsIm5ld0xvYWRlckRhdGEiLCJtZXJnZWRMb2FkZXJEYXRhIiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNSIsImVycm9yTWVzc2FnZSIsIm9iaiIsInNpZ25hbHMiLCJpc1JldmFsaWRhdGluZ0xvYWRlciIsInVud3JhcCIsImdldEFsbCIsIl93aW5kb3ciLCJ0cmFuc2l0aW9ucyIsInNlc3Npb25Qb3NpdGlvbnMiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwiVU5TQUZFX0RlZmVycmVkRGF0YSIsIlVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCIsIlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCIsIlVOU0FGRV9jb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwiVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMiLCJVTlNBRkVfaW52YXJpYW50IiwiVU5TQUZFX3dhcm5pbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@remix-run/router/dist/router.js\n");

/***/ })

};
;